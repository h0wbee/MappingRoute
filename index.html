<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Mapping Rute Pengiriman</title>
  <style>
    :root {
      --primary: #6366f1;
      --primary-dark: #4f46e5;
      --primary-light: #818cf8;
      --secondary: #10b981;
      --accent: #f59e0b;
      --danger: #ef4444;
      --success: #10b981;
      --warning: #f59e0b;
      --info: #3b82f6;
      --gradient-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      --gradient-secondary: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      --gradient-success: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
      --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
      --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
    }
    
    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; 
      margin: 0; 
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      background-attachment: fixed;
      color: #1e293b;
      line-height: 1.6;
    }
    header { 
      padding: 20px 24px; 
      border-bottom: none;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      box-shadow: var(--shadow-lg);
      position: relative;
      z-index: 1000;
    }
    header::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0.1) 100%);
    }
    .header-content {
      display: flex;
      align-items: center;
      gap: 16px;
    }
    h1 { 
      margin: 0; 
      font-size: 24px; 
      font-weight: 700;
      color: #fff;
      letter-spacing: -0.025em;
      text-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    /* Loading Overlay dengan Animasi Truck */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      -webkit-backdrop-filter: blur(4px);
      backdrop-filter: blur(4px);
      z-index: 3000;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    .loading-overlay.show {
      display: flex;
      opacity: 1;
    }
    .loading-content {
      text-align: center;
      color: #fff;
    }
    .loading-text {
      font-size: 20px;
      font-weight: 600;
      margin-top: 20px;
      color: #fff;
      text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    .truck-container {
      width: 100%;
      height: 100px;
      position: relative;
      overflow: hidden;
      margin-bottom: 20px;
    }
    .truck {
      position: absolute;
      width: 80px;
      height: 80px;
      left: -100px;
      top: 50%;
      transform: translateY(-50%);
      animation: truckMove 3s ease-in-out infinite;
    }
    .truck svg {
      width: 100%;
      height: 100%;
      filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
    }
    @keyframes truckMove {
      0% {
        left: -100px;
      }
      50% {
        left: calc(50% - 40px);
      }
      100% {
        left: calc(100% + 100px);
      }
    }
    .road {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 4px;
      background: linear-gradient(90deg, 
        rgba(255,255,255,0.1) 0%, 
        rgba(255,255,255,0.3) 50%, 
        rgba(255,255,255,0.1) 100%);
      animation: roadMove 1s linear infinite;
    }
    @keyframes roadMove {
      0% {
        background-position: 0 0;
      }
      100% {
        background-position: 50px 0;
      }
    }
    
    /* Modal Styles */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.6);
      -webkit-backdrop-filter: blur(4px);
      backdrop-filter: blur(4px);
      z-index: 2000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .modal.show {
      opacity: 1;
      visibility: visible;
    }
    .modal-content {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.95);
      background: #fff;
      border-radius: 24px;
      box-shadow: var(--shadow-xl);
      width: 90%;
      max-width: 1000px;
      max-height: 90vh;
      overflow: hidden;
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .modal.show .modal-content {
      transform: translate(-50%, -50%) scale(1);
    }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 28px 32px;
      border-bottom: 2px solid #e2e8f0;
      background: var(--gradient-primary);
      position: relative;
    }
    .modal-header::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0.1) 100%);
    }
    .modal-header h2 {
      margin: 0;
      font-size: 22px;
      font-weight: 700;
      color: #fff;
      text-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .close-modal {
      background: rgba(255, 255, 255, 0.2);
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: #fff;
      padding: 6px;
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
      transition: all 0.2s ease;
    }
    .close-modal:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: rotate(90deg);
    }
    .modal-body {
      padding: 32px;
      max-height: 60vh;
      overflow-y: auto;
      background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
    }
    .modal-tabs {
      display: flex;
      border-bottom: 2px solid #e2e8f0;
      margin-bottom: 24px;
      background: linear-gradient(135deg, #f8fafc 0%, #ffffff 100%);
      border-radius: 12px 12px 0 0;
      padding: 4px 4px 0 4px;
    }
    .tab-btn {
      background: transparent;
      border: none;
      padding: 14px 24px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      color: #64748b;
      border-bottom: 3px solid transparent;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      border-radius: 12px 12px 0 0;
    }
    .tab-btn::after {
      content: '';
      position: absolute;
      bottom: -2px;
      left: 50%;
      transform: translateX(-50%) scaleX(0);
      width: 80%;
      height: 3px;
      background: var(--gradient-primary);
      border-radius: 2px 2px 0 0;
      transition: transform 0.3s ease;
    }
    .tab-btn.active {
      color: var(--primary-dark);
      font-weight: 600;
      background: rgba(99, 102, 241, 0.05);
    }
    .tab-btn.active::after {
      transform: translateX(-50%) scaleX(1);
    }
    .tab-btn:hover {
      color: var(--primary);
      background: rgba(99, 102, 241, 0.05);
    }
    .tab-content {
      margin-bottom: 20px;
    }
    .tab-pane {
      display: none;
    }
    .tab-pane.active {
      display: block;
    }
    .modal-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
      background: #fff;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: var(--shadow-sm);
    }
    .modal-table th {
      background: var(--gradient-primary);
      color: #fff;
      font-weight: 600;
      text-align: left;
      padding: 16px;
      border-bottom: 2px solid rgba(255,255,255,0.2);
      text-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }
    .modal-table td {
      padding: 14px 16px;
      border-bottom: 1px solid #f1f5f9;
      color: #475569;
    }
    .modal-table tbody tr {
      transition: all 0.2s ease;
    }
    .modal-table tbody tr:hover {
      background: linear-gradient(90deg, rgba(99, 102, 241, 0.05) 0%, rgba(99, 102, 241, 0.02) 100%);
      transform: scale(1.01);
    }
    .modal-table tfoot td {
      font-weight: 600;
      background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
      border-top: 2px solid #e2e8f0;
      color: var(--primary-dark);
    }
    .modal-actions {
      display: flex;
      gap: 12px;
      justify-content: center;
      padding-top: 24px;
      border-top: 2px solid #e2e8f0;
      margin-top: 24px;
    }
    .download-btn {
      background: var(--gradient-primary);
      color: #fff;
      border: none;
      border-radius: 12px;
      padding: 14px 24px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: var(--shadow-md);
    }
    .download-btn:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }
    .download-btn.secondary {
      background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
      color: #475569;
      border: 2px solid #e2e8f0;
    }
    .download-btn.secondary:hover {
      background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
      border-color: var(--primary-light);
      color: var(--primary-dark);
    }
    
    /* Action buttons dalam modal */
    .modal-table .action-buttons {
      display: flex;
      gap: 6px;
      justify-content: center;
    }
    .modal-table .action-buttons button {
      padding: 8px 12px;
      font-size: 12px;
      height: auto;
      min-width: 36px;
      border-radius: 8px;
      background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
      color: #475569;
      border: 2px solid #e2e8f0;
      transition: all 0.2s ease;
      box-shadow: var(--shadow-sm);
    }
    .modal-table .action-buttons button:hover {
      background: linear-gradient(135deg, #e2e8f0 0%, #cbd5e1 100%);
      border-color: var(--primary-light);
      color: var(--primary-dark);
      transform: translateY(-1px);
      box-shadow: var(--shadow-md);
    }
    .modal-table .action-buttons button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    
    main { 
      display: grid; 
      grid-template-columns: 360px 1fr; 
      grid-template-rows: auto 1fr;
      gap: 24px; 
      padding: 24px; 
      max-width: 1400px;
      margin: 0 auto;
      min-height: calc(100vh - 80px);
    }
    .panel { 
      background: #fff;
      border: none;
      border-radius: 20px; 
      padding: 28px; 
      box-shadow: var(--shadow-xl);
      height: fit-content;
      position: relative;
      overflow: hidden;
      transition: all 0.3s ease;
    }
    .panel::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: var(--gradient-primary);
    }
    .panel:hover {
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.15);
      transform: translateY(-2px);
    }
    .row { 
      display: grid; 
      grid-template-columns: 1fr; 
      gap: 8px; 
      margin-bottom: 16px; 
    }
    label { 
      font-size: 14px; 
      font-weight: 600;
      color: #475569; 
      margin-bottom: 6px;
      display: block;
    }
    input[type="text"], input[type="number"], select { 
      width: 100%; 
      box-sizing: border-box; 
      padding: 14px 18px; 
      border: 2px solid #e2e8f0; 
      border-radius: 12px; 
      font-size: 14px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      background: #fff;
      color: #1e293b;
    }
    input[type="text"]:hover, input[type="number"]:hover, select:hover {
      border-color: var(--primary-light);
    }
    input[type="text"]:focus, input[type="number"]:focus, select:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.1);
      transform: translateY(-1px);
    }
    input[type="number"] {
      -moz-appearance: textfield;
      appearance: textfield;
    }
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    input[type="text"]:disabled {
      background-color: #f8fafc !important;
      color: #64748b;
      cursor: not-allowed;
      border-color: #e2e8f0;
    }
    select {
      cursor: pointer;
      appearance: none;
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right 12px center;
      background-size: 16px;
      padding-right: 40px;
    }
    .inline { display: flex; align-items: center; gap: 8px; }
    .muted { 
      color: #64748b; 
      font-size: 13px; 
      line-height: 1.5;
      margin-top: 4px;
    }
    button { 
      appearance: none; 
      border: none; 
      background: var(--gradient-primary); 
      color: #fff; 
      border-radius: 12px; 
      padding: 14px 24px; 
      cursor: pointer; 
      font-size: 14px;
      font-weight: 600;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: var(--shadow-md);
      position: relative;
      overflow: hidden;
    }
    button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s;
    }
    button:hover::before {
      left: 100%;
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }
    button:active {
      transform: translateY(0);
      box-shadow: var(--shadow-sm);
    }
    button.secondary { 
      background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%); 
      color: #475569; 
      border: 2px solid #e2e8f0;
      box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    }
    button.secondary:hover {
      background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
      border-color: var(--primary-light);
      color: var(--primary-dark);
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }
    button.ghost { 
      background: transparent; 
      color: var(--primary); 
      box-shadow: none;
    }
    button.ghost:hover {
      background: rgba(99, 102, 241, 0.1);
      color: var(--primary-dark);
    }
    button.danger {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
    }
    button.danger:hover {
      background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
    }
    button.success {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
    }
    button.success:hover {
      background: linear-gradient(135deg, #059669 0%, #047857 100%);
    }
    button:disabled { 
      opacity: 0.5; 
      cursor: not-allowed; 
      transform: none;
      background: #cbd5e1;
    }
    button:disabled:hover {
      transform: none;
      box-shadow: var(--shadow-md);
    }
    #map { 
      width: 100%; 
      height: 100%; 
      min-height: 500px;
      border: none; 
      border-radius: 20px; 
      box-shadow: var(--shadow-xl);
      overflow: hidden;
    }
    main > section:last-child {
      grid-column: 2;
      grid-row: 2;
    }
    .customers { 
      display: flex; 
      flex-direction: column; 
      gap: 12px; 
      max-height: 400px;
      overflow-y: auto;
      padding: 8px;
    }
    .customer-list-item { 
      background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
      border: 2px solid #e2e8f0; 
      border-radius: 12px; 
      padding: 12px 16px; 
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    .customer-list-item::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 4px;
      height: 100%;
      background: var(--gradient-primary);
      transform: scaleY(0);
      transition: transform 0.3s ease;
    }
    .customer-list-item:hover {
      border-color: var(--primary-light);
      box-shadow: var(--shadow-md);
      transform: translateY(-1px);
    }
    .customer-list-item:hover::before {
      transform: scaleY(1);
    }
    .customer-list-item.dragging {
      opacity: 0.5;
      transform: scale(0.95);
      cursor: grabbing;
    }
    .customer-list-item.drag-over {
      border-color: var(--primary);
      background: linear-gradient(135deg, #e0f2fe 0%, #f0f9ff 100%);
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }
    .customer-list-item.drag-over::before {
      transform: scaleY(1);
      background: var(--primary);
    }
    .customer-list-drag-handle {
      cursor: grab;
      padding: 8px;
      margin-right: 8px;
      color: var(--text-muted);
      font-size: 18px;
      -webkit-user-select: none;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      transition: color 0.2s ease;
    }
    .customer-list-drag-handle:hover {
      color: var(--primary);
    }
    .customer-list-drag-handle:active {
      cursor: grabbing;
    }
    .customer-list-info {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 0;
    }
    .customer-list-name {
      font-weight: 600;
      color: var(--text-primary);
      font-size: 14px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .customer-list-doc {
      font-size: 12px;
      color: var(--text-secondary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .customer-list-address {
      font-size: 11px;
      color: var(--text-muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      margin-top: 2px;
    }
    .customer-list-actions {
      display: flex;
      gap: 8px;
      flex-shrink: 0;
    }
    .customer-list-actions button {
      padding: 6px 12px;
      font-size: 12px;
      min-width: auto;
    }
    .customer-item { 
      background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
      border: 2px solid #e2e8f0; 
      border-radius: 16px; 
      padding: 20px; 
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
    }
    .customer-item::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 4px;
      height: 100%;
      background: var(--gradient-primary);
      transform: scaleY(0);
      transition: transform 0.3s ease;
    }
    .customer-item:hover {
      border-color: var(--primary-light);
      box-shadow: var(--shadow-lg);
      transform: translateY(-2px);
    }
    .customer-item:hover::before {
      transform: scaleY(1);
    }
    .flex { display: flex; gap: 8px; }
    .flex > * { flex: 1; }
    .results { margin-top: 16px; }
    table { 
      width: 100%; 
      border-collapse: collapse; 
      font-size: 13px;
      background: #fff;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: var(--shadow-sm);
    }
    th { 
      text-align: left; 
      padding: 12px 14px; 
      border-bottom: 2px solid #e2e8f0;
      background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
      font-weight: 600;
      color: #475569;
    }
    td { 
      text-align: left; 
      padding: 10px 14px; 
      border-bottom: 1px solid #f1f5f9;
      color: #64748b;
    }
    tbody tr {
      transition: all 0.2s ease;
    }
    tbody tr:hover {
      background: rgba(99, 102, 241, 0.02);
    }
    tfoot td { 
      font-weight: 600; 
      background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
      border-top: 2px solid #e2e8f0;
      color: var(--primary-dark);
    }
    .error { 
      color: #dc2626; 
      font-size: 13px; 
      margin-top: 8px; 
      padding: 14px 18px;
      background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);
      border: 2px solid #fecaca;
      border-left: 4px solid #ef4444;
      border-radius: 12px;
      font-weight: 500;
      box-shadow: var(--shadow-sm);
    }
    .error.success {
      color: #059669;
      background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
      border: 2px solid #86efac;
      border-left: 4px solid #10b981;
    }
    .drop-list { margin-top: 10px; border-top: 1px solid #eee; padding-top: 8px; }
    .drop-item { 
      display: grid; 
      grid-template-columns: 28px 1fr auto; 
      gap: 8px; 
      align-items: center; 
      padding: 10px 0; 
      border-bottom: 1px dashed #e2e8f0;
      transition: all 0.2s ease;
    }
    .drop-item:hover {
      background: rgba(99, 102, 241, 0.02);
      border-radius: 8px;
      padding-left: 8px;
      padding-right: 8px;
    }
    .chip { 
      display: inline-block; 
      padding: 4px 12px; 
      border-radius: 12px; 
      font-size: 11px; 
      font-weight: 600;
      color: #fff; 
      box-shadow: var(--shadow-sm);
      background: var(--gradient-primary);
    }
    .controls button { 
      padding: 6px 12px; 
      font-size: 12px;
      border-radius: 8px;
    }
    .legend { 
      display: flex; 
      flex-wrap: wrap; 
      gap: 12px; 
      margin-top: 12px;
      padding: 12px;
      background: linear-gradient(135deg, #f8fafc 0%, #ffffff 100%);
      border-radius: 12px;
      border: 1px solid #e2e8f0;
    }
    .legend-item { 
      display: inline-flex; 
      align-items: center; 
      gap: 8px; 
      font-size: 12px;
      font-weight: 500;
      color: #475569;
    }
    .legend-swatch { 
      width: 16px; 
      height: 16px; 
      border-radius: 4px;
      box-shadow: var(--shadow-sm);
    }
    .results-title { margin: 8px 0; font-size: 14px; }
    .table-container { overflow-x: auto; }
    .muted-note { margin-top: 8px; }
    .hidden { display: none; }
    .inline-between { justify-content: space-between; }
    .add-customer-btn-container {
      margin-top: 12px;
    }
    .upload-actions {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .file-input-hidden {
      display: none;
    }
    
    /* CSS untuk Google Places Autocomplete dropdown */
    .pac-container {
      z-index: 3000 !important;
      border-radius: 12px !important;
      box-shadow: var(--shadow-xl) !important;
      border: 2px solid #e2e8f0 !important;
      margin-top: 4px !important;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif !important;
    }
    .pac-item {
      padding: 12px 16px !important;
      cursor: pointer !important;
      border-bottom: 1px solid #f1f5f9 !important;
      transition: background-color 0.2s ease !important;
    }
    .pac-item:hover {
      background-color: #f8fafc !important;
    }
    .pac-item-selected {
      background-color: rgba(99, 102, 241, 0.1) !important;
    }
    .pac-icon {
      margin-right: 8px !important;
    }
    .pac-matched {
      font-weight: 600 !important;
      color: var(--primary) !important;
    }
    
    /* Tab switcher styles untuk form panel */
    .form-tabs {
      display: flex;
      border-bottom: 2px solid #e2e8f0;
      margin-bottom: 24px;
      gap: 0;
      background: linear-gradient(135deg, #f8fafc 0%, #ffffff 100%);
      border-radius: 12px 12px 0 0;
      padding: 4px 4px 0 4px;
    }
    .form-tab-btn {
      background: transparent;
      border: none;
      padding: 14px 24px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      color: #64748b;
      border-bottom: 3px solid transparent;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      border-radius: 12px 12px 0 0;
    }
    .form-tab-btn::after {
      content: '';
      position: absolute;
      bottom: -2px;
      left: 50%;
      transform: translateX(-50%) scaleX(0);
      width: 80%;
      height: 3px;
      background: var(--gradient-primary);
      border-radius: 2px 2px 0 0;
      transition: transform 0.3s ease;
    }
    .form-tab-btn.active {
      color: var(--primary-dark);
      font-weight: 600;
      background: rgba(99, 102, 241, 0.05);
    }
    .form-tab-btn.active::after {
      transform: translateX(-50%) scaleX(1);
    }
    .form-tab-btn:hover {
      color: var(--primary);
      background: rgba(99, 102, 241, 0.05);
    }
    .form-tab-content {
      display: none;
    }
    .form-tab-content.active {
      display: block;
    }
    
    /* CSS untuk modal customer */
    .modal-content.customer-modal {
      max-width: 600px;
    }
    .modal-hybrid-toggle {
      display: none;
    }
    .modal-hybrid-toggle-container {
      gap: 16px;
      margin-top: 8px;
    }
    .modal-radio-label {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      font-weight: normal;
    }
    .modal-coord-fields {
      display: none;
    }
    .modal-address-fields {
      display: block;
    }
    .modal-form-actions {
      justify-content: flex-end;
      margin-top: 20px;
    }
    .hidden {
      display: none !important;
    }
    .visible {
      display: block !important;
    }
    
    /* Download buttons styles */
    .download-buttons {
      margin-top: 16px;
      gap: 8px;
    }
    .download-btn {
      flex: 1;
    }
    
    /* Mobile responsive untuk download buttons */
    @media (max-width: 768px) {
      .download-buttons {
        flex-direction: column;
        gap: 6px;
      }
      .download-btn {
        flex: none;
        width: 100%;
        min-height: 44px;
      }
    }
    
    
    /* Desktop specific styles */
    @media (min-width: 1024px) {
      /* Ensure proper desktop layout */
      main {
        grid-template-columns: 400px 1fr;
        gap: 24px;
        transition: margin-left 0.3s ease;
      }
      .panel {
        grid-column: 1;
        grid-row: 1 / -1;
      }
      /* Modal untuk desktop */
      .modal-content {
        max-width: 1200px;
        width: 85%;
      }
      .modal-actions {
        flex-direction: row;
        justify-content: center;
      }
      .download-btn {
        min-width: 150px;
      }
    }

    /* Tablet Responsive Styles */
    @media (max-width: 1023px) and (min-width: 769px) {
      main {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr;
        gap: 16px;
      }
      .panel {
        grid-column: 1;
        grid-row: 1;
      }
      main > section:last-child {
        grid-column: 1;
        grid-row: 2;
      }
      .modal-content {
        width: 90%;
        max-width: 900px;
      }
    }

    /* Mobile Responsive Styles */
    @media (max-width: 768px) {
      body { font-size: 14px; }
      header { padding: 8px 12px; }
      h1 { font-size: 16px; }
      .modal-content {
        width: 95%;
        max-height: 95vh;
      }
      .modal-actions {
        flex-direction: column;
        gap: 8px;
      }
      .download-btn {
        width: 100%;
        justify-content: center;
      }
      .modal-table .action-buttons {
        flex-direction: column;
        gap: 2px;
      }
      .modal-table .action-buttons button {
        padding: 8px;
        font-size: 14px;
        min-width: 40px;
      }
      main { 
        display: flex; 
        flex-direction: column; 
        padding: 8px; 
        gap: 8px; 
      }
      .panel { 
        order: 1;
        margin-bottom: 20px; 
        padding: 15px; 
        min-height: 50vh;
        animation: slideDown 0.5s;
      }
      /* Animasi untuk customer-item */
      .customer-item {
        animation: fadeInScale 0.4s;
      }
      /* Animasi tombol proses */
      #processBtn {
        transition: background 0.2s, transform 0.2s;
      }
      #processBtn:active {
        transform: scale(0.97);
      }
      /* Ensure proper order: form panel first, then map */
      #form-panel {
        order: 1;
      }
      main > section:last-child {
        order: 2;
        margin-top: 20px;
      }
      #map { 
        height: 60vh; 
        min-height: 400px; 
        margin-bottom: 12px; 
      }
      .inline { 
        flex-direction: column; 
        align-items: stretch; 
        gap: 6px; 
      }
      .inline button { 
        align-self: flex-start; 
        width: auto; 
      }
      .flex { 
        flex-direction: column; 
        gap: 6px; 
      }
      .flex > * { 
        flex: none; 
      }
      table { 
        font-size: 11px; 
        min-width: 100%; 
      }
      th, td { 
        padding: 4px 6px; 
        min-width: 60px; 
      }
      .drop-item { 
        grid-template-columns: 24px 1fr; 
        gap: 6px; 
        padding: 8px 0; 
      }
      .drop-item .controls { 
        grid-column: 1 / -1; 
        display: flex; 
        justify-content: flex-end; 
        gap: 4px; 
        margin-top: 4px; 
      }
      .controls button { 
        padding: 6px 8px; 
        font-size: 11px; 
      }
      .chip { 
        font-size: 11px; 
        padding: 1px 6px; 
      }
      .legend { 
        flex-direction: column; 
        gap: 4px; 
      }
      .legend-item { 
        font-size: 11px; 
      }
      .customer-item { 
        padding: 8px; 
      }
      .customer-item .row { 
        margin-bottom: 8px; 
      }
      .customer-item input { 
        padding: 6px; 
        font-size: 14px; 
      }
      .customer-item label { 
        font-size: 11px; 
        margin-bottom: 2px; 
      }
      button { 
        padding: 10px 12px; 
        font-size: 14px; 
        min-height: 44px; 
      }
      .muted { 
        font-size: 11px; 
        line-height: 1.4; 
      }
      .error { 
        font-size: 11px; 
        line-height: 1.4; 
      }
    }

    @media (max-width: 480px) {
      header { padding: 6px 8px; }
      h1 { font-size: 14px; }
      main { padding: 6px; }
      .panel { padding: 8px; }
      #map { 
        height: 40vh; 
        min-height: 250px; 
      }
      table { font-size: 10px; }
      th, td { 
        padding: 3px 4px; 
        min-width: 50px; 
      }
      .drop-item { 
        padding: 6px 0; 
      }
      .customer-item { 
        padding: 6px; 
      }
      .customer-item input { 
        padding: 5px; 
        font-size: 13px; 
      }
      button { 
        padding: 8px 10px; 
        font-size: 13px; 
        min-height: 40px; 
      }
    }

    /* Touch-friendly improvements */
    @media (hover: none) and (pointer: coarse) {
      button { 
        min-height: 44px; 
        padding: 12px 16px; 
      }
      .controls button { 
        min-height: 36px; 
        padding: 8px 12px; 
      }
      input[type="text"], input[type="number"], select { 
        min-height: 44px; 
        padding: 12px; 
        font-size: 16px; 
      }
      .drop-item { 
        padding: 12px 0; 
      }
    }

    /* Landscape mobile optimization */
    @media (max-width: 768px) and (orientation: landscape) {
      #map { 
        height: 70vh; 
        min-height: 300px; 
      }
      .panel { 
        max-height: 25vh; 
        overflow-y: auto; 
        min-height: 25vh;
      }
    }

    /* Prevent horizontal scroll on mobile */
    @media (max-width: 768px) {
      body { 
        overflow-x: hidden; 
        overflow-y: auto;
      }
      main { 
        width: 100%; 
        max-width: 100vw; 
        min-height: 100vh;
      }
      .panel { 
        width: 100%; 
        max-width: 100%; 
        box-sizing: border-box; 
      }
      /* Add visual indicator that there's content below */
      .panel::after {
        content: "‚Üì Scroll ke bawah untuk melihat peta";
        display: block;
        text-align: center;
        color: #666;
        font-size: 12px;
        margin-top: 15px;
        padding: 10px;
        border-top: 1px dashed #ddd;
      }
    }

    /* Improve text selection on mobile */
    @media (max-width: 768px) {
      input[type="text"], input[type="number"] { 
        -webkit-appearance: none; 
        appearance: none; 
        border-radius: 6px; 
      }
      button { 
        -webkit-tap-highlight-color: transparent; 
        -webkit-touch-callout: none; 
        -webkit-user-select: none; 
        user-select: none; 
      }
    }

    /* Animasi keyframes */
    @keyframes fadeInUp {
      from { opacity: 0; transform: translateY(30px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes slideDown {
      from { opacity: 0; transform: translateY(-30px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes fadeInScale {
      from { opacity: 0; transform: scale(0.95); }
      to { opacity: 1; transform: scale(1); }
    }
  </style>
</head>
<body>
  <header>
    <div class="header-content">
      <h1>Mapping Rute Pengiriman</h1>
      <h4>by Ilham Apps</h4>
    </div>
  </header>
  
  <!-- Loading Overlay dengan Animasi Truck -->
  <div id="loadingOverlay" class="loading-overlay">
    <div class="loading-content">
      <div class="truck-container">
        <div class="truck">
          <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
            <!-- Truck Body -->
            <rect x="20" y="40" width="50" height="30" fill="#6366f1" rx="3"/>
            <!-- Truck Cabin -->
            <rect x="5" y="35" width="20" height="35" fill="#4f46e5" rx="2"/>
            <!-- Truck Window -->
            <rect x="8" y="38" width="14" height="12" fill="#c7d2fe" rx="1"/>
            <!-- Truck Wheels -->
            <circle cx="25" cy="75" r="8" fill="#1e293b"/>
            <circle cx="25" cy="75" r="5" fill="#475569"/>
            <circle cx="65" cy="75" r="8" fill="#1e293b"/>
            <circle cx="65" cy="75" r="5" fill="#475569"/>
            <!-- Truck Details -->
            <rect x="25" y="45" width="15" height="8" fill="#818cf8" rx="1"/>
            <rect x="45" y="45" width="15" height="8" fill="#818cf8" rx="1"/>
            <!-- Truck Light -->
            <circle cx="70" cy="55" r="3" fill="#fbbf24"/>
          </svg>
        </div>
        <div class="road"></div>
      </div>
      <div class="loading-text">Memproses Rute Pengiriman...</div>
    </div>
  </div>
  
  <!-- Modal untuk Ringkasan Rute -->
  <div id="routeModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Ringkasan Rute Pengiriman</h2>
        <button id="closeModal" class="close-modal">&times;</button>
      </div>
      <div class="modal-body">
        <div class="modal-tabs">
          <button class="tab-btn active" data-tab="summary">Ringkasan Rute</button>
          <button class="tab-btn" data-tab="drops">Daftar Drop Points</button>
        </div>
        
        <div class="tab-content">
          <div id="summaryTab" class="tab-pane active">
            <div class="table-container">
              <table class="modal-table">
                <thead>
                  <tr>
                    <th>#</th>
                    <th>Dari</th>
                    <th>Ke</th>
                    <th>Jarak</th>
                    <th>Durasi</th>
                  </tr>
                </thead>
                <tbody id="modalLegsBody"></tbody>
                <tfoot>
                  <tr>
                    <td colspan="3">Total</td>
                    <td id="modalTotalDistance">-</td>
                    <td id="modalTotalDuration">-</td>
                  </tr>
                </tfoot>
              </table>
            </div>
          </div>
          
          <div id="dropsTab" class="tab-pane">
            <div class="table-container">
              <table class="modal-table">
                <thead>
                  <tr>
                    <th>#</th>
                    <th>Nama Customer</th>
                    <th>No. Dokumen</th>
                    <th>Alamat</th>
                    <th>Notes</th>
                    <th>Urutan</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody id="modalDropBody"></tbody>
              </table>
            </div>
          </div>
        </div>
        
        <div class="modal-actions">
          <button id="modalDownloadPdf" class="download-btn">üìÑ Download PDF</button>
          <button id="modalDownloadExcel" class="download-btn">üìä Download Excel</button>
          <button id="modalDownloadImg" class="download-btn">üñºÔ∏è Download Gambar</button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Modal untuk Form Customer -->
  <div id="customerModal" class="modal">
    <div class="modal-content customer-modal">
      <div class="modal-header">
        <h2 id="customerModalTitle">Tambah Customer</h2>
        <button id="closeCustomerModal" class="close-modal">&times;</button>
      </div>
      <div class="modal-body">
        <form id="customerForm">
          <div class="row">
            <label for="modalCustName">Nama Customer</label>
            <input id="modalCustName" type="text" placeholder="Nama customer" required>
          </div>
          <div class="row">
            <label for="modalCustDoc">Nomor Dokumen</label>
            <input id="modalCustDoc" type="text" placeholder="Contoh: DO-2025-0001" required>
          </div>
          <!-- Toggle untuk mode hybrid (hanya muncul saat mode hybrid) -->
          <div id="modalHybridToggle" class="modal-hybrid-toggle">
            <div class="row">
              <label>Pilih Tipe Input</label>
              <div class="inline modal-hybrid-toggle-container">
                <label class="modal-radio-label">
                  <input type="radio" name="hybridInputType" value="address" id="hybridInputAddress" checked>
                  <span>üìç Alamat Lengkap</span>
                </label>
                <label class="modal-radio-label">
                  <input type="radio" name="hybridInputType" value="coordinates" id="hybridInputCoordinates">
                  <span>üåê Koordinat (Lat/Lng)</span>
                </label>
              </div>
            </div>
          </div>
          <!-- Form fields untuk tab alamat -->
          <div id="modalAddressFields" class="modal-address-fields">
            <div class="row">
              <label for="modalCustAddr">Alamat Customer</label>
              <input id="modalCustAddr" type="text" placeholder="Ketik alamat atau paste URL Google Maps...">
            </div>
          </div>
          <!-- Form fields untuk tab koordinat -->
          <div id="modalCoordFields" class="modal-coord-fields">
            <div class="row">
              <label for="modalCustLat">Latitude</label>
              <input id="modalCustLat" type="number" step="any" placeholder="-6.2088">
            </div>
            <div class="row">
              <label for="modalCustLng">Longitude</label>
              <input id="modalCustLng" type="number" step="any" placeholder="106.8456">
            </div>
          </div>
          <div class="row">
            <label for="modalCustNotes">Notes</label>
            <input id="modalCustNotes" type="text" placeholder="Catatan tambahan (opsional)">
          </div>
          <div class="inline modal-form-actions">
            <button type="button" id="cancelCustomerBtn" class="secondary">Batal</button>
            <button type="submit" id="saveCustomerBtn" class="primary">Simpan</button>
          </div>
        </form>
      </div>
    </div>
  </div>
  
  <main>
    <section class="panel" id="form-panel">
      <div class="row">
        <label for="storeSelect">Pilih Toko</label>
        <select id="storeSelect">
          <option value="">-- Pilih Toko dari Database --</option>
        </select>
        <div class="muted">Pilih toko untuk mengisi otomatis kota dan alamat toko.</div>
      </div>
      <div class="row">
        <label for="cityInput">Kota</label>
        <input id="cityInput" type="text" placeholder="Contoh: Jakarta, Bandung, Surabaya">
        <div class="muted">Menentukan kota akan membuat saran alamat lebih relevan.</div>
      </div>
      <div class="row">
        <label for="storeAddress">Alamat Toko (Origin)</label>
        <div class="inline">
          <input id="storeAddress" type="text" placeholder="Ketik alamat atau paste URL Google Maps...">
          <button id="lockStoreBtn" class="secondary" title="Kunci/Unlock alamat toko">Kunci</button>
        </div>
        <div class="muted">Pilih toko dari dropdown di atas untuk auto-fill, atau ketik manual jika tidak ada di database.</div>
      </div>

      <!-- Tab Switcher -->
      <div class="form-tabs">
        <button class="form-tab-btn" data-form-tab="address">üìç Alamat Lengkap</button>
        <button class="form-tab-btn" data-form-tab="coordinates">üåê Koordinat (Lat/Lng)</button>
        <button class="form-tab-btn active" data-form-tab="hybrid">üîÄ Hybrid (Alamat + Koordinat)</button>
      </div>

      <!-- Tab Content: Alamat Lengkap -->
      <div id="addressTab" class="form-tab-content">
        <div class="row">
          <div class="inline inline-between">
            <label>Daftar Customer</label>
            <div class="upload-actions">
              <button id="downloadTemplateAddressBtn" class="ghost" type="button" title="Download Template Excel">üì• Template Excel</button>
              <button id="uploadAddressBtn" class="ghost" type="button">üì§ Upload Excel</button>
              <input type="file" id="uploadAddressFile" accept=".xlsx,.xls" class="file-input-hidden">
            </div>
          </div>
          <div id="customers" class="customers"></div>
          <div class="add-customer-btn-container">
            <button id="addCustomerBtn" class="ghost">+ Tambah Customer</button>
          </div>
        </div>
      </div>

      <!-- Tab Content: Koordinat (Lat/Lng) -->
      <div id="coordinatesTab" class="form-tab-content">
        <div class="row">
          <div class="inline inline-between">
            <label>Daftar Customer (Koordinat)</label>
            <div class="upload-actions">
              <button id="downloadTemplateCoordBtn" class="ghost" type="button" title="Download Template Excel">üì• Template Excel</button>
              <button id="uploadCoordBtn" class="ghost" type="button">üì§ Upload Excel</button>
              <input type="file" id="uploadCoordFile" accept=".xlsx,.xls" class="file-input-hidden">
            </div>
          </div>
          <div id="customersCoord" class="customers"></div>
          <div class="add-customer-btn-container">
            <button id="addCustomerCoordBtn" class="ghost">+ Tambah Customer</button>
          </div>
        </div>
        <div class="muted muted-note">
          Masukkan koordinat dalam format: Latitude, Longitude (contoh: -6.2088, 106.8456)
        </div>
      </div>

      <!-- Tab Content: Hybrid (Alamat + Koordinat) -->
      <div id="hybridTab" class="form-tab-content active">
        <div class="row">
          <div class="inline inline-between">
            <label>Daftar Customer (Hybrid)</label>
            <div class="upload-actions">
              <button id="downloadTemplateHybridBtn" class="ghost" type="button" title="Download Template Excel">üì• Template Excel</button>
              <button id="uploadHybridBtn" class="ghost" type="button">üì§ Upload Excel</button>
              <input type="file" id="uploadHybridFile" accept=".xlsx,.xls" class="file-input-hidden">
            </div>
          </div>
          <div id="customersHybrid" class="customers"></div>
          <div class="add-customer-btn-container">
            <button id="addCustomerHybridBtn" class="ghost">+ Tambah Customer</button>
          </div>
        </div>
        <div class="muted muted-note">
          Anda dapat menggunakan alamat lengkap atau koordinat untuk setiap customer. Pilih salah satu saat menambah customer.<br>
          <strong>Catatan:</strong> Tidak ada batasan maksimal untuk upload data. Jika koordinat kosong atau tidak valid, sistem akan otomatis menggunakan alamat. Untuk proses rute, data akan dibagi menjadi batch (maksimal 25 customer per batch) sesuai batasan Google Maps API.
        </div>
      </div>

      <div class="inline">
        <button id="processBtn">Proses Rute</button>
        <button id="resetBtn" class="secondary">Reset</button>
      </div>
      <div id="errorBox" class="error hidden"></div>

      <!-- Button untuk membuka ringkasan rute -->
      <div class="inline hidden" id="summaryButtonContainer">
        <button id="viewSummaryBtn" class="primary">üìä Lihat Ringkasan Rute</button>
      </div>

      <div class="muted muted-note">
        Catatan: Gunakan Autocomplete Google untuk akurasi titik peta. Masukkan API key Anda sebelum menggunakan.
      </div>
    </section>
    
    
    <section>
      <div id="map"></div>
    </section>
  </main>

  <!-- Library untuk PDF, Image, dan Excel Download -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  
  <script>
    let map;
    let directionsService;
    let directionsRenderer;
    let distanceMatrixService;
    let storeAutocomplete;
    let cityAutocomplete;
    let geocoder;
    let customerAutocompletes = [];
    let isStoreLocked = false;
    let customMarkers = [];
    let customPolylines = [];
    let infoWindow;
    let cityPlace = null;
    let currentRouteData = null; // Menyimpan data rute saat ini
    let truckMarker = null; // Marker untuk animasi truk
    let animationInterval = null; // Interval untuk animasi
    let storeDatabase = []; // Menyimpan data toko dari JSON
    let selectedStoreData = null; // Menyimpan data toko yang dipilih dari database (termasuk koordinat)

    const dom = {
      cityInput: () => document.getElementById('cityInput'),
      storeAddress: () => document.getElementById('storeAddress'),
      storeSelect: () => document.getElementById('storeSelect'),
      lockStoreBtn: () => document.getElementById('lockStoreBtn'),
      addCustomerBtn: () => document.getElementById('addCustomerBtn'),
      customers: () => document.getElementById('customers'),
      processBtn: () => document.getElementById('processBtn'),
      resetBtn: () => document.getElementById('resetBtn'),
      errorBox: () => document.getElementById('errorBox'),
      loadingOverlay: () => document.getElementById('loadingOverlay'),
      // Download buttons
      downloadButtons: () => document.getElementById('downloadButtons'),
      downloadPdfBtn: () => document.getElementById('downloadPdfBtn'),
      downloadXlsxBtn: () => document.getElementById('downloadXlsxBtn'),
      downloadImgBtn: () => document.getElementById('downloadImgBtn'),
      // Modal elements
      routeModal: () => document.getElementById('routeModal'),
      closeModal: () => document.getElementById('closeModal'),
      viewSummaryBtn: () => document.getElementById('viewSummaryBtn'),
      summaryButtonContainer: () => document.getElementById('summaryButtonContainer'),
      modalLegsBody: () => document.getElementById('modalLegsBody'),
      modalTotalDistance: () => document.getElementById('modalTotalDistance'),
      modalTotalDuration: () => document.getElementById('modalTotalDuration'),
      modalDropBody: () => document.getElementById('modalDropBody'),
      modalDownloadPdf: () => document.getElementById('modalDownloadPdf'),
      modalDownloadExcel: () => document.getElementById('modalDownloadExcel'),
      modalDownloadImg: () => document.getElementById('modalDownloadImg'),
      // Customer modal elements
      customerModal: () => document.getElementById('customerModal'),
      closeCustomerModal: () => document.getElementById('closeCustomerModal'),
      customerModalTitle: () => document.getElementById('customerModalTitle'),
      customerForm: () => document.getElementById('customerForm'),
      modalCustName: () => document.getElementById('modalCustName'),
      modalCustDoc: () => document.getElementById('modalCustDoc'),
      modalCustAddr: () => document.getElementById('modalCustAddr'),
      modalCustLat: () => document.getElementById('modalCustLat'),
      modalCustLng: () => document.getElementById('modalCustLng'),
      modalCustNotes: () => document.getElementById('modalCustNotes'),
      modalAddressFields: () => document.getElementById('modalAddressFields'),
      modalCoordFields: () => document.getElementById('modalCoordFields'),
      cancelCustomerBtn: () => document.getElementById('cancelCustomerBtn'),
    };

    const ROUTE_COLORS = ['#1e88e5','#43a047','#f4511e','#8e24aa','#fb8c00','#3949ab','#00acc1','#6d4c41','#e53935','#7cb342'];

    // Fungsi untuk mengontrol modal
    function openModal() {
      const modal = dom.routeModal();
      modal.classList.add('show');
      document.body.style.overflow = 'hidden';
    }

    function closeModal() {
      const modal = dom.routeModal();
      modal.classList.remove('show');
      document.body.style.overflow = 'auto';
    }

    // Fungsi untuk mengontrol tabs dalam modal
    function switchTab(tabName) {
      // Remove active class from all tabs and panes
      document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
      document.querySelectorAll('.tab-pane').forEach(pane => pane.classList.remove('active'));
      
      // Add active class to selected tab and pane
      document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
      document.getElementById(`${tabName}Tab`).classList.add('active');
    }

    // Fungsi untuk mengisi modal dengan data rute
    function populateModal() {
      if (!currentRouteData) return;

      // Isi ringkasan rute
      const modalLegsBody = dom.modalLegsBody();
      modalLegsBody.innerHTML = '';
      
      currentRouteData.legs.forEach((leg, index) => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${index + 1}</td>
          <td>${leg.start_address}</td>
          <td>${leg.end_address}</td>
          <td>${leg.distance?.text || '-'}</td>
          <td>${leg.duration?.text || '-'}</td>
        `;
        modalLegsBody.appendChild(tr);
      });

      // Update total
      dom.modalTotalDistance().textContent = currentRouteData.totalDistance;
      dom.modalTotalDuration().textContent = currentRouteData.totalDuration;

      // Isi daftar drop points
      const modalDropBody = dom.modalDropBody();
      modalDropBody.innerHTML = '';
      
      currentRouteData.dropPoints.forEach((drop, index) => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${index + 1}</td>
          <td>${drop.name}</td>
          <td>${drop.docNo}</td>
          <td>${drop.address}</td>
          <td>${drop.notes || '-'}</td>
          <td>Drop ${index + 1}</td>
          <td>
            <div class="action-buttons">
              <button type="button" class="secondary" data-act="up" data-idx="${index}" title="Pindah ke atas">‚ñ≤</button>
              <button type="button" class="secondary" data-act="down" data-idx="${index}" title="Pindah ke bawah">‚ñº</button>
            </div>
          </td>
        `;
        modalDropBody.appendChild(tr);
      });

      // Tambahkan event listeners untuk button action di modal
      modalDropBody.querySelectorAll('button').forEach(btn => {
        btn.addEventListener('click', async (e) => {
          const act = e.currentTarget.getAttribute('data-act');
          const idx = parseInt(e.currentTarget.getAttribute('data-idx'));
          const newOrder = currentRouteData.dropPoints.map((_, i) => i);
          
          if (act === 'up' && idx > 0) {
            [newOrder[idx-1], newOrder[idx]] = [newOrder[idx], newOrder[idx-1]];
          } else if (act === 'down' && idx < newOrder.length - 1) {
            [newOrder[idx+1], newOrder[idx]] = [newOrder[idx], newOrder[idx+1]];
          } else {
            return;
          }
          
          // Reorder drop points
          const reorderedDrops = newOrder.map(i => currentRouteData.dropPoints[i]);
          currentRouteData.dropPoints = reorderedDrops;
          
          // Update modal display
          populateModal();
          
          // Update route jika ada data rute yang tersimpan
          if (currentRouteData.legs && currentRouteData.legs.length > 0) {
            try {
              // Re-render route dengan urutan baru
              await rerenderWithOrderFromModal(reorderedDrops, newOrder);
            } catch (error) {
              console.error('Error re-rendering route:', error);
              showError('Gagal memperbarui rute. Silakan coba lagi.');
            }
          }
        });
      });
    }

    // Fungsi untuk re-render route dari modal
    async function rerenderWithOrderFromModal(reorderedDrops, newOrder) {
      try {
        const storeResolved = await getStoreOrigin();
        const origin = storeResolved.location;
        
        // Buat waypoints dari drop points yang sudah di-reorder
        const waypoints = reorderedDrops.map(drop => {
          // Jika ada koordinat asli (dari tab koordinat), gunakan itu
          if (drop.latitude !== undefined && drop.longitude !== undefined) {
            const location = new google.maps.LatLng(drop.latitude, drop.longitude);
            return { location: location, stopover: true };
          }
          // Jika tidak ada koordinat, cari dari data rute yang ada
          const leg = currentRouteData.legs.find(l => 
            l.end_address.includes(drop.name) || 
            l.end_address.includes(drop.docNo)
          );
          if (leg && leg.end_location) {
            return { location: leg.end_location, stopover: true };
          }
          // Fallback: gunakan geocoding
          return { location: drop.address, stopover: true };
        });

        const request = {
          origin,
          destination: origin,
          travelMode: google.maps.TravelMode.DRIVING,
          provideRouteAlternatives: false,
          optimizeWaypoints: false,
          waypoints,
        };
        
        // Konversi reorderedDrops ke format customerInfo untuk error handling
        const resolvedCustomersFromDrops = reorderedDrops.map((drop, idx) => {
          let location;
          if (drop.latitude !== undefined && drop.longitude !== undefined) {
            location = new google.maps.LatLng(drop.latitude, drop.longitude);
          } else {
            // Gunakan waypoint location jika ada
            location = waypoints[idx]?.location || null;
          }
          return {
            name: drop.name,
            docNo: drop.docNo,
            formatted: drop.address,
            address: drop.address,
            location: location,
            lat: drop.latitude,
            lng: drop.longitude,
            notes: drop.notes || ''
          };
        });
        
        // Siapkan informasi customer untuk error handling
        const customerInfo = {
          customers: resolvedCustomersFromDrops,
          order: newOrder || resolvedCustomersFromDrops.map((_, idx) => idx),
          startIndex: 0
        };
        
        const response = await getDirections(request, customerInfo);
        
        // Update currentRouteData dengan data baru
        let totalMeters = 0;
        let totalSeconds = 0;
        response.routes[0].legs.forEach(leg => {
          totalMeters += leg.distance?.value || 0;
          totalSeconds += leg.duration?.value || 0;
        });

        currentRouteData.legs = response.routes[0].legs;
        currentRouteData.totalDistance = formatDistance(totalMeters);
        currentRouteData.totalDuration = formatDuration(totalSeconds);
        
        // Buat resolvedCustomers dari reorderedDrops dan legs yang baru
        // Catatan: legs[0] = origin -> drop[0], legs[1] = drop[0] -> drop[1], dst
        const resolvedCustomers = await Promise.all(reorderedDrops.map(async (drop, idx) => {
          // Leg untuk drop point ini adalah leg[idx] (karena leg[0] adalah dari origin ke drop pertama)
          const leg = response.routes[0].legs[idx];
          // Waypoint untuk drop point ini
          const waypoint = waypoints[idx];
          
          // Gunakan location dari waypoint (yang sudah menggunakan koordinat asli jika tersedia)
          const location = waypoint && waypoint.location ? waypoint.location : (leg ? leg.end_location : null);
          
          // Jika ada koordinat asli, gunakan reverse geocoding untuk mendapatkan alamat yang sesuai
          let formattedAddress = drop.address || 'Alamat tidak tersedia';
          if (drop.latitude !== undefined && drop.longitude !== undefined && location) {
            try {
              // Reverse geocode untuk mendapatkan alamat dari koordinat asli
              const geocodeResp = await new Promise((resolve, reject) => {
                geocoder.geocode({ location: location }, (results, status) => {
                  if (status === 'OK' && results[0]) {
                    resolve(results[0]);
                  } else {
                    reject(new Error('Geocoding failed'));
                  }
                });
              });
              formattedAddress = geocodeResp.formatted_address;
            } catch (error) {
              // Jika reverse geocoding gagal, gunakan alamat dari leg atau fallback
              formattedAddress = (leg && leg.end_address) ? leg.end_address : drop.address;
            }
          } else {
            // Jika tidak ada koordinat asli, gunakan alamat dari leg
            formattedAddress = (leg && leg.end_address) ? leg.end_address : drop.address;
          }
          
          return {
            name: drop.name,
            docNo: drop.docNo,
            formatted: formattedAddress,
            location: location,
            notes: drop.notes || ''
          };
        }));
        
        // newOrder untuk renderRoute harus berupa array berurutan karena resolvedCustomers sudah sesuai urutan
        const renderOrder = resolvedCustomers.map((_, idx) => idx);
        
        // Re-render route di peta
        renderRoute(response, { geometry: { location: origin }, formatted_address: storeResolved.formatted }, renderOrder, resolvedCustomers);
        
        // Update modal dengan data baru
        populateModal();
        
      } catch (err) {
        console.error('Error re-rendering route from modal:', err);
        throw err;
      }
    }

    // Fungsi untuk memuat data storeDatabase.json
    async function loadStoreDatabase() {
      try {
        const response = await fetch('storeDatabase.json');
        storeDatabase = await response.json();
        populateStoreSelect();
      } catch (error) {
        console.error('Error loading store database:', error);
        showError('Gagal memuat database toko. Silakan refresh halaman.');
      }
    }

    // Fungsi untuk mengisi dropdown store
    function populateStoreSelect() {
      const select = dom.storeSelect();
      select.innerHTML = '<option value="">-- Pilih Toko dari Database --</option>';
      
      storeDatabase.forEach((store, index) => {
        const option = document.createElement('option');
        option.value = index;
        option.textContent = store.store;
        select.appendChild(option);
      });
    }

    // Fungsi untuk mengekstrak kota dari alamat
    function extractCityFromAddress(address) {
      // Coba ekstrak kota dari alamat berdasarkan pola umum
      const cityPatterns = [
        /Kota\s+([^,]+)/i,
        /Kabupaten\s+([^,]+)/i,
        /Kec\.\s+([^,]+)/i,
        /,([^,]+),/i
      ];
      
      for (const pattern of cityPatterns) {
        const match = address.match(pattern);
        if (match) {
          return match[1].trim();
        }
      }
      
      // Fallback: ambil kata terakhir sebelum koma terakhir
      const parts = address.split(',');
      if (parts.length > 1) {
        return parts[parts.length - 2].trim();
      }
      
      return '';
    }

    // Fungsi untuk auto-fill kota dan alamat toko
    function handleStoreSelection() {
      const selectedIndex = dom.storeSelect().value;
      if (selectedIndex === '') {
        // Reset ke mode manual input
        selectedStoreData = null; // Reset selected store data
        clearMarkers(); // Hapus marker toko
        dom.storeAddress().disabled = false;
        dom.storeAddress().placeholder = 'Ketik alamat atau paste URL Google Maps...';
        dom.storeAddress().style.backgroundColor = '#fff';
        dom.storeAddress().style.cursor = 'text';
        return;
      }
      
      const selectedStore = storeDatabase[selectedIndex];
      if (selectedStore) {
        // Simpan data toko yang dipilih termasuk koordinat
        selectedStoreData = {
          store: selectedStore.store,
          address: selectedStore.address,
          latitude: selectedStore.latitude,
          longitude: selectedStore.longitude,
          postal_code: selectedStore.postal_code
        };
        
        // Auto-fill alamat toko dan buat read-only
        dom.storeAddress().value = selectedStore.address;
        dom.storeAddress().disabled = true;
        dom.storeAddress().placeholder = 'Alamat toko dari database (read-only)';
        dom.storeAddress().style.backgroundColor = '#f8fafc';
        dom.storeAddress().style.cursor = 'not-allowed';
        
        // Gunakan koordinat dari database untuk menampilkan marker dan mengatur viewport
        if (selectedStore.latitude && selectedStore.longitude) {
          const storeLocation = new google.maps.LatLng(selectedStore.latitude, selectedStore.longitude);
          
          // Update map viewport ke lokasi toko
          map.setCenter(storeLocation);
          map.setZoom(13);
          
          // Tampilkan marker toko di peta
          clearMarkers(); // Hapus marker sebelumnya jika ada
          placeMarker(storeLocation, 'Toko: ' + selectedStore.store + ' ‚Äî ' + selectedStore.address);
          
          // Auto-fill kota dengan alamat lengkap
          const city = extractCityFromAddress(selectedStore.address);
          if (city) {
            // Gunakan geocoding untuk mendapatkan alamat lengkap kota
            geocoder.geocode({ 
              address: city + ', Indonesia',
              region: 'id'
            }, (results, status) => {
              if (status === 'OK' && results[0]) {
                const fullCityPlace = results[0];
                dom.cityInput().value = fullCityPlace.formatted_address;
                
                // Update cityPlace global variable
                cityPlace = fullCityPlace;
                
                // Update bounds untuk autocomplete
                if (fullCityPlace.geometry && fullCityPlace.geometry.viewport) {
                  applyCityBiasToAutocompletes();
                }
              } else {
                // Fallback ke nama kota saja jika geocoding gagal
                dom.cityInput().value = city;
              }
            });
          }
        } else {
          // Jika tidak ada koordinat di database, gunakan geocoding seperti sebelumnya
          const city = extractCityFromAddress(selectedStore.address);
          if (city) {
            geocoder.geocode({ 
              address: city + ', Indonesia',
              region: 'id'
            }, (results, status) => {
              if (status === 'OK' && results[0]) {
                const fullCityPlace = results[0];
                dom.cityInput().value = fullCityPlace.formatted_address;
                cityPlace = fullCityPlace;
                if (fullCityPlace.geometry && fullCityPlace.geometry.viewport) {
                  map.fitBounds(fullCityPlace.geometry.viewport);
                  applyCityBiasToAutocompletes();
                }
              } else {
                dom.cityInput().value = city;
              }
            });
          }
        }
        
        // Update customer autocompletes dengan kota baru setelah geocoding selesai
        setTimeout(() => {
          if (typeof updateExistingCustomerAutocompletes === 'function') {
            updateExistingCustomerAutocompletes();
          }
        }, 1000);
      }
    }

    function formatDistance(meters) {
      if (meters < 1000) return meters.toFixed(0) + ' m';
      return (meters / 1000).toFixed(2) + ' km';
    }

    function formatDuration(seconds) {
      const mins = Math.round(seconds / 60);
      if (mins < 60) return mins + ' min';
      const hours = Math.floor(mins / 60);
      const rem = mins % 60;
      return hours + ' jam ' + (rem ? rem + ' mnt' : '');
    }

    function showError(message) {
      const box = dom.errorBox();
      // Gunakan innerHTML untuk format yang lebih baik, tapi sanitize dulu
      box.innerHTML = message.split('\n').map(line => {
        // Escape HTML untuk keamanan
        const escaped = line.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        // Format khusus untuk emoji dan header
        if (line.trim().startsWith('‚ö†Ô∏è') || line.trim().startsWith('üí°') || line.trim().startsWith('üìã') || line.trim().startsWith('üìç')) {
          return `<div style="margin-top: 8px; font-weight: 600;">${escaped}</div>`;
        } else if (line.trim().match(/^\d+\./)) {
          return `<div style="margin-left: 20px; margin-top: 4px;">${escaped}</div>`;
        } else if (line.trim().startsWith('-')) {
          return `<div style="margin-left: 20px; margin-top: 2px; font-size: 12px;">${escaped}</div>`;
        } else {
          return `<div style="margin-top: 4px;">${escaped}</div>`;
        }
      }).join('');
      box.classList.remove('hidden', 'success');
      box.classList.add('error');
      // Scroll ke error box
      setTimeout(() => {
        box.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }, 100);
    }

    function showSuccess(message) {
      const box = dom.errorBox();
      box.textContent = message;
      box.classList.remove('hidden', 'error');
      box.classList.add('success');
    }

    function clearError() {
      const box = dom.errorBox();
      box.textContent = '';
      box.classList.add('hidden');
      box.classList.remove('error', 'success');
    }

    function showLoading() {
      const overlay = dom.loadingOverlay();
      overlay.classList.add('show');
      document.body.style.overflow = 'hidden';
    }

    function hideLoading() {
      const overlay = dom.loadingOverlay();
      overlay.classList.remove('show');
      document.body.style.overflow = '';
    }

    // Fungsi untuk menginterpretasikan error status dari Google Maps Directions API
    function interpretDirectionsError(status, request, customerInfo = null) {
      let errorMessage = '';
      let suggestions = [];
      let problemCustomers = [];

      // Jika ada informasi customer, identifikasi customer yang bermasalah
      if (customerInfo && customerInfo.customers) {
        const { customers, order, startIndex } = customerInfo;
        const waypoints = request.waypoints || [];
        
        // Untuk ZERO_RESULTS dan NOT_FOUND, identifikasi customer yang bermasalah
        if (status === 'ZERO_RESULTS' || status === 'NOT_FOUND') {
          // Tampilkan semua customer dalam batch/request yang bermasalah
          if (order && customers && order.length > 0) {
            order.forEach((customerIdx, idx) => {
              // Pastikan customerIdx valid
              if (customerIdx >= 0 && customerIdx < customers.length) {
                const customer = customers[customerIdx];
                if (customer) {
                  // Dapatkan koordinat dengan berbagai cara
                  let coordinates = null;
                  if (customer.location) {
                    if (typeof customer.location.lat === 'function') {
                      coordinates = `${customer.location.lat()}, ${customer.location.lng()}`;
                    } else if (customer.location.lat && customer.location.lng) {
                      coordinates = `${customer.location.lat}, ${customer.location.lng}`;
                    }
                  } else if (customer.lat !== undefined && customer.lng !== undefined) {
                    coordinates = `${customer.lat}, ${customer.lng}`;
                  }
                  
                  problemCustomers.push({
                    index: (startIndex || 0) + idx + 1,
                    name: customer.name || 'Tanpa Nama',
                    docNo: customer.docNo || '-',
                    address: customer.formatted || customer.address || 'Tidak diketahui',
                    coordinates: coordinates
                  });
                }
              }
            });
          } else if (customers && customers.length > 0) {
            // Jika tidak ada order, gunakan semua customers
            customers.forEach((customer, idx) => {
              let coordinates = null;
              if (customer.location) {
                if (typeof customer.location.lat === 'function') {
                  coordinates = `${customer.location.lat()}, ${customer.location.lng()}`;
                } else if (customer.location.lat && customer.location.lng) {
                  coordinates = `${customer.location.lat}, ${customer.location.lng}`;
                }
              } else if (customer.lat !== undefined && customer.lng !== undefined) {
                coordinates = `${customer.lat}, ${customer.lng}`;
              }
              
              problemCustomers.push({
                index: (startIndex || 0) + idx + 1,
                name: customer.name || 'Tanpa Nama',
                docNo: customer.docNo || '-',
                address: customer.formatted || customer.address || 'Tidak diketahui',
                coordinates: coordinates
              });
            });
          }
        }
      }

      switch (status) {
        case 'ZERO_RESULTS':
          errorMessage = 'Tidak dapat menemukan rute antara titik asal dan tujuan.';
          suggestions = [
            'Pastikan alamat toko (origin) dan alamat customer valid dan dapat diakses',
            'Periksa apakah ada rute yang dapat dilalui (tidak terputus oleh laut, dll)',
            'Coba gunakan koordinat yang lebih akurat jika menggunakan mode koordinat',
            'Pastikan semua alamat berada di wilayah yang sama atau terhubung dengan jalan',
            'Jika menggunakan mode hybrid, pastikan alamat atau koordinat yang digunakan valid'
          ];
          break;

        case 'NOT_FOUND':
          errorMessage = 'Salah satu atau beberapa alamat tidak ditemukan.';
          suggestions = [
            'Periksa kembali alamat toko (origin) - pastikan alamat lengkap dan benar',
            'Periksa semua alamat customer - pastikan tidak ada typo atau alamat yang tidak valid',
            'Coba gunakan Google Places Autocomplete untuk memastikan alamat valid',
            'Jika menggunakan koordinat, pastikan koordinat dalam format yang benar (lat, lng)'
          ];
          break;

        case 'OVER_QUERY_LIMIT':
          errorMessage = 'Batas penggunaan API telah terlampaui.';
          suggestions = [
            'Tunggu beberapa saat sebelum mencoba lagi',
            'Periksa quota API key Anda di Google Cloud Console',
            'Pertimbangkan untuk upgrade API key atau menunggu reset quota'
          ];
          break;

        case 'REQUEST_DENIED':
          errorMessage = 'Request ditolak oleh Google Maps API.';
          suggestions = [
            'Periksa apakah API key valid dan aktif',
            'Pastikan Directions API sudah diaktifkan di Google Cloud Console',
            'Periksa apakah ada restriction pada API key yang menghalangi request',
            'Pastikan billing account sudah diaktifkan jika diperlukan'
          ];
          break;

        case 'INVALID_REQUEST':
          errorMessage = 'Request tidak valid.';
          suggestions = [
            'Pastikan semua field wajib sudah diisi (alamat toko dan minimal 1 customer)',
            'Periksa format koordinat jika menggunakan mode koordinat (harus angka valid)',
            'Pastikan tidak ada karakter khusus yang tidak valid dalam alamat',
            'Coba reset form dan input ulang data'
          ];
          break;

        default:
          errorMessage = `Terjadi kesalahan saat menghitung rute (Status: ${status}).`;
          suggestions = [
            'Periksa koneksi internet Anda',
            'Coba refresh halaman dan ulangi proses',
            'Pastikan API key Google Maps valid dan aktif',
            'Jika masalah berlanjut, hubungi administrator sistem'
          ];
      }

      // Buat pesan error yang informatif
      let fullMessage = `‚ö†Ô∏è ${errorMessage}\n\n`;
      
      // Tambahkan informasi customer yang bermasalah jika ada
      if (problemCustomers.length > 0) {
        fullMessage += `üîç Customer yang Perlu Dicek (${problemCustomers.length} customer):\n\n`;
        problemCustomers.forEach((customer, idx) => {
          fullMessage += `üìå Customer #${customer.index} (Baris ${customer.index}):\n`;
          fullMessage += `   ‚Ä¢ Nama: ${customer.name}\n`;
          fullMessage += `   ‚Ä¢ No. Dokumen: ${customer.docNo}\n`;
          if (customer.address && customer.address !== 'Tidak diketahui') {
            fullMessage += `   ‚Ä¢ Alamat: ${customer.address.substring(0, 80)}${customer.address.length > 80 ? '...' : ''}\n`;
          }
          if (customer.coordinates) {
            fullMessage += `   ‚Ä¢ Koordinat: ${customer.coordinates}\n`;
          }
          fullMessage += `   ‚ö†Ô∏è Periksa alamat atau koordinat customer ini!\n\n`;
        });
      }
      
      if (suggestions.length > 0) {
        fullMessage += 'üí° Saran perbaikan:\n';
        suggestions.forEach((suggestion, index) => {
          fullMessage += `${index + 1}. ${suggestion}\n`;
        });
      }

      // Tambahkan informasi detail untuk debugging (hanya untuk error tertentu)
      if (request && (status === 'ZERO_RESULTS' || status === 'NOT_FOUND')) {
        const originInfo = typeof request.origin === 'string' ? request.origin : 
                          (request.origin?.lat && request.origin?.lng ? 
                           `${request.origin.lat()}, ${request.origin.lng()}` : 'Tidak diketahui');
        const destInfo = typeof request.destination === 'string' ? request.destination : 
                         (request.destination?.lat && request.destination?.lng ? 
                          `${request.destination.lat()}, ${request.destination.lng()}` : 'Tidak diketahui');
        const waypointCount = request.waypoints ? request.waypoints.length : 0;
        
        fullMessage += `\nüìã Detail Request:\n`;
        fullMessage += `- Titik Asal (Origin): ${originInfo.substring(0, 100)}${originInfo.length > 100 ? '...' : ''}\n`;
        fullMessage += `- Titik Tujuan (Destination): ${destInfo.substring(0, 100)}${destInfo.length > 100 ? '...' : ''}\n`;
        if (waypointCount > 0) {
          fullMessage += `- Jumlah Titik Perhentian: ${waypointCount}\n`;
        }
      }

      return fullMessage;
    }

    // Fungsi helper untuk memanggil directionsService.route() dengan error handling yang proper
    function getDirections(request, customerInfo = null) {
      return new Promise((resolve, reject) => {
        directionsService.route(request, (response, status) => {
          if (status === 'OK' && response.routes && response.routes.length > 0) {
            resolve(response);
          } else {
            const errorMessage = interpretDirectionsError(status, request, customerInfo);
            reject(new Error(errorMessage));
          }
        });
      });
    }

    // Fungsi untuk switch form tab
    function switchFormTab(tabName) {
      // Remove active class from all tabs and panes
      document.querySelectorAll('.form-tab-btn').forEach(btn => btn.classList.remove('active'));
      document.querySelectorAll('.form-tab-content').forEach(pane => pane.classList.remove('active'));
      
      // Add active class to selected tab and pane
      document.querySelector(`[data-form-tab="${tabName}"]`).classList.add('active');
      document.getElementById(`${tabName}Tab`).classList.add('active');
      
      // Update modal fields berdasarkan tab aktif
      updateCustomerModalFields(tabName);
    }

    // Array untuk menyimpan data customer
    let customersData = {
      address: [],
      coordinates: [],
      hybrid: []
    };
    let editingCustomerIndex = null;
    let editingCustomerType = null; // 'address', 'coordinates', atau 'hybrid'

    // Fungsi untuk update modal fields berdasarkan tab aktif
    function updateCustomerModalFields(tabName) {
      const modalHybridToggle = document.getElementById('modalHybridToggle');
      const modalAddressFields = dom.modalAddressFields();
      const modalCoordFields = dom.modalCoordFields();
      
      if (tabName === 'address') {
        modalHybridToggle.classList.add('modal-hybrid-toggle');
        modalAddressFields.classList.remove('hidden');
        modalAddressFields.classList.add('visible');
        modalCoordFields.classList.add('modal-coord-fields');
        dom.modalCustAddr().required = true;
        dom.modalCustLat().required = false;
        dom.modalCustLng().required = false;
      } else if (tabName === 'coordinates') {
        modalHybridToggle.classList.add('modal-hybrid-toggle');
        modalAddressFields.classList.add('hidden');
        modalAddressFields.classList.remove('visible');
        modalCoordFields.classList.remove('modal-coord-fields');
        modalCoordFields.classList.remove('hidden');
        modalCoordFields.classList.add('visible');
        dom.modalCustAddr().required = false;
        dom.modalCustLat().required = true;
        dom.modalCustLng().required = true;
      } else if (tabName === 'hybrid') {
        // Mode hybrid: tampilkan toggle dan kedua field
        modalHybridToggle.classList.remove('modal-hybrid-toggle');
        // Default ke alamat
        const hybridInputType = document.querySelector('input[name="hybridInputType"]:checked')?.value || 'address';
        if (hybridInputType === 'address') {
          modalAddressFields.classList.remove('hidden');
          modalAddressFields.classList.add('visible');
          modalCoordFields.classList.add('modal-coord-fields');
          dom.modalCustAddr().required = true;
          dom.modalCustLat().required = false;
          dom.modalCustLng().required = false;
          // Setup autocomplete setelah field terlihat
          setTimeout(() => {
            setupAddressAutocomplete();
          }, 200);
        } else {
          modalAddressFields.classList.add('hidden');
          modalAddressFields.classList.remove('visible');
          modalCoordFields.classList.remove('modal-coord-fields');
          modalCoordFields.classList.remove('hidden');
          modalCoordFields.classList.add('visible');
          dom.modalCustAddr().required = false;
          dom.modalCustLat().required = true;
          dom.modalCustLng().required = true;
        }
      }
      
      // Setup autocomplete untuk tab address
      if (tabName === 'address') {
        setTimeout(() => {
          setupAddressAutocomplete();
        }, 200);
      }
    }

    // Fungsi untuk membuka modal customer
    function openCustomerModal(type = null, index = null) {
      const activeTab = document.querySelector('.form-tab-btn.active').dataset.formTab;
      const customerType = type || activeTab;
      
      editingCustomerIndex = index;
      editingCustomerType = customerType;
      
      // Update modal fields
      updateCustomerModalFields(customerType);
      
      // Reset form
      dom.customerForm().reset();
      
      // Jika edit mode, isi form dengan data yang ada
      if (index !== null) {
        const customer = customersData[customerType][index];
        dom.modalCustName().value = customer.name || '';
        dom.modalCustDoc().value = customer.docNo || '';
        dom.modalCustNotes().value = customer.notes || '';
        
        if (customerType === 'address') {
          dom.modalCustAddr().value = customer.address || '';
        } else if (customerType === 'coordinates') {
          dom.modalCustLat().value = customer.lat || '';
          dom.modalCustLng().value = customer.lng || '';
        } else if (customerType === 'hybrid') {
          // Untuk hybrid, tentukan apakah menggunakan alamat atau koordinat
          if (customer.address) {
            // Menggunakan alamat
            document.getElementById('hybridInputAddress').checked = true;
            dom.modalCustAddr().value = customer.address || '';
            updateCustomerModalFields('hybrid');
          } else if (customer.lat !== undefined && customer.lng !== undefined) {
            // Menggunakan koordinat
            document.getElementById('hybridInputCoordinates').checked = true;
            dom.modalCustLat().value = customer.lat || '';
            dom.modalCustLng().value = customer.lng || '';
            updateCustomerModalFields('hybrid');
          }
        }
        
        dom.customerModalTitle().textContent = 'Edit Customer';
      } else {
        dom.customerModalTitle().textContent = 'Tambah Customer';
      }
      
      // Buka modal
      const modal = dom.customerModal();
      modal.classList.add('show');
      document.body.style.overflow = 'hidden';
      
      // Setup autocomplete untuk alamat jika tab address atau hybrid dengan alamat
      // Delay lebih lama untuk memastikan modal sudah ter-render sepenuhnya dan input field visible
      setTimeout(() => {
        // Pastikan modal sudah ter-render
        const modalContent = document.querySelector('.modal-content');
        if (!modalContent || !modalContent.offsetParent) {
          // Jika modal belum ter-render, coba lagi
          setTimeout(() => {
            if (customerType === 'address') {
              setupAddressAutocomplete();
            } else if (customerType === 'hybrid') {
              const hybridInputType = document.querySelector('input[name="hybridInputType"]:checked')?.value || 'address';
              if (hybridInputType === 'address') {
                setupAddressAutocomplete();
              }
            }
          }, 300);
          return;
        }
        
        if (customerType === 'address') {
          setupAddressAutocomplete();
        } else if (customerType === 'hybrid') {
          // Untuk hybrid, setup autocomplete jika pilih alamat
          const hybridInputType = document.querySelector('input[name="hybridInputType"]:checked')?.value || 'address';
          if (hybridInputType === 'address') {
            setupAddressAutocomplete();
          }
        }
      }, 500);
      
      // Event listener untuk toggle hybrid input type menggunakan event delegation
      // untuk menghindari masalah dengan event listener yang duplikat
      if (customerType === 'hybrid') {
        // Hapus event listener lama jika ada
        const form = dom.customerForm();
        if (form._hybridToggleHandler) {
          form.removeEventListener('change', form._hybridToggleHandler);
        }
        
        // Buat handler baru
        const hybridToggleHandler = (e) => {
          if (e.target && e.target.name === 'hybridInputType') {
            updateCustomerModalFields('hybrid');
            // Setup autocomplete jika pilih alamat dengan delay untuk memastikan field terlihat
            if (e.target.value === 'address') {
              setTimeout(() => {
                setupAddressAutocomplete();
              }, 300);
            }
          }
        };
        
        // Simpan reference handler
        form._hybridToggleHandler = hybridToggleHandler;
        
        // Gunakan event delegation pada form
        form.addEventListener('change', hybridToggleHandler);
      }
    }

    // Fungsi untuk menutup modal customer
    function closeCustomerModal() {
      const modal = dom.customerModal();
      modal.classList.remove('show');
      document.body.style.overflow = 'auto';
      editingCustomerIndex = null;
      editingCustomerType = null;
      
      // Bersihkan event listener hybrid toggle jika ada
      const form = dom.customerForm();
      if (form._hybridToggleHandler) {
        form.removeEventListener('change', form._hybridToggleHandler);
        delete form._hybridToggleHandler;
      }
      
      // Bersihkan autocomplete jika ada
      const addrInput = dom.modalCustAddr();
      if (addrInput && addrInput._autocomplete) {
        try {
          google.maps.event.clearInstanceListeners(addrInput._autocomplete);
        } catch (e) {
          // Ignore error
        }
        delete addrInput._autocomplete;
      }
      
      // Reset form
      dom.customerForm().reset();
    }

    // Fungsi untuk setup autocomplete pada input alamat di modal
    function setupAddressAutocomplete(retryCount = 0) {
      const addrInput = dom.modalCustAddr();
      
      // Pastikan input ada di DOM
      if (!addrInput) {
        console.warn('Input alamat tidak ditemukan');
        if (retryCount < 3) {
          setTimeout(() => setupAddressAutocomplete(retryCount + 1), 200);
        }
        return;
      }
      
      // Pastikan input terlihat dan tidak disabled
      const computedStyle = window.getComputedStyle(addrInput);
      const isVisible = computedStyle.display !== 'none' && 
                       computedStyle.visibility !== 'hidden' &&
                       addrInput.offsetParent !== null;
      
      if (!isVisible) {
        console.warn('Input alamat tidak terlihat, menunda setup autocomplete');
        if (retryCount < 3) {
          setTimeout(() => setupAddressAutocomplete(retryCount + 1), 200);
        }
        return;
      }
      
      // Pastikan input tidak disabled atau readonly
      if (addrInput.disabled || addrInput.readOnly) {
        addrInput.disabled = false;
        addrInput.readOnly = false;
      }
      
      // Hapus autocomplete yang sudah ada jika ada
      if (addrInput._autocomplete) {
        try {
          google.maps.event.clearInstanceListeners(addrInput._autocomplete);
        } catch (e) {
          // Ignore error jika autocomplete sudah dihapus
        }
        delete addrInput._autocomplete;
      }
      
      // Hapus event listener 'input' yang lama jika ada
      if (addrInput._inputListener) {
        addrInput.removeEventListener('input', addrInput._inputListener);
        delete addrInput._inputListener;
      }
      
      try {
        // Pastikan Google Maps API sudah loaded
        if (typeof google === 'undefined' || !google.maps || !google.maps.places) {
          console.error('Google Maps Places API belum dimuat');
          if (retryCount < 5) {
            setTimeout(() => setupAddressAutocomplete(retryCount + 1), 300);
          }
          return;
        }
        
        // Pastikan input memiliki position yang benar untuk dropdown
        const inputStyle = window.getComputedStyle(addrInput);
        if (inputStyle.position === 'static') {
          addrInput.style.position = 'relative';
        }
        
        // Buat autocomplete
        const autocomplete = new google.maps.places.Autocomplete(addrInput, {
          fields: ['geometry', 'formatted_address', 'name', 'address_components'],
          types: ['geocode'],
          componentRestrictions: { country: ['id'] },
        });
        
        // Set bounds jika ada cityPlace
        if (cityPlace && cityPlace.geometry && cityPlace.geometry.viewport) {
          autocomplete.setBounds(cityPlace.geometry.viewport);
          autocomplete.setOptions({ strictBounds: false });
        }
        
        // Simpan reference ke autocomplete
        addrInput._autocomplete = autocomplete;
        
        // Event listener untuk ketika place dipilih
        autocomplete.addListener('place_changed', () => {
          const place = autocomplete.getPlace();
          if (place && place.formatted_address) {
            addrInput.value = place.formatted_address;
          }
        });
        
        // Google Places Autocomplete sudah menangani input event secara otomatis
        // Tidak perlu menambahkan event listener manual yang bisa menyebabkan infinite loop
        
        console.log('Autocomplete berhasil di-setup untuk input alamat');
        
      } catch (error) {
        console.error('Error setting up autocomplete:', error);
        if (retryCount < 3) {
          setTimeout(() => setupAddressAutocomplete(retryCount + 1), 200);
        }
      }
    }

    // Fungsi untuk render list customer yang compact
    function renderCustomerList(type) {
      let container;
      if (type === 'address') {
        container = dom.customers();
      } else if (type === 'coordinates') {
        container = document.getElementById('customersCoord');
      } else if (type === 'hybrid') {
        container = document.getElementById('customersHybrid');
      }
      
      if (!container) return;
      
      container.innerHTML = '';
      
      const customers = customersData[type];
      
      if (customers.length === 0) {
        const emptyMsg = document.createElement('div');
        emptyMsg.className = 'muted';
        emptyMsg.style.textAlign = 'center';
        emptyMsg.style.padding = '20px';
        emptyMsg.textContent = 'Belum ada customer. Klik "Tambah Customer" untuk menambahkan.';
        container.appendChild(emptyMsg);
        return;
      }
      
      // Helper function untuk menentukan posisi drop
      function getDragAfterElement(container, y) {
        const draggableElements = [...container.querySelectorAll('.customer-list-item:not(.dragging)')];
        
        return draggableElements.reduce((closest, child) => {
          const box = child.getBoundingClientRect();
          const offset = y - box.top - box.height / 2;
          
          if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
          } else {
            return closest;
          }
        }, { offset: Number.NEGATIVE_INFINITY }).element;
      }
      
      let draggedIndex = null;
      
      customers.forEach((customer, index) => {
        const listItem = document.createElement('div');
        listItem.className = 'customer-list-item';
        listItem.draggable = true;
        listItem.dataset.index = index;
        listItem.dataset.type = type;
        
        let addressDisplay = '';
        if (type === 'address') {
          addressDisplay = customer.address;
        } else if (type === 'coordinates') {
          addressDisplay = `${customer.lat || ''}, ${customer.lng || ''}`;
        } else if (type === 'hybrid') {
          // Untuk hybrid, tampilkan alamat jika ada, atau koordinat jika tidak ada alamat
          if (customer.address) {
            addressDisplay = `üìç ${customer.address}`;
          } else if (customer.lat !== undefined && customer.lng !== undefined) {
            addressDisplay = `üåê ${customer.lat}, ${customer.lng}`;
          }
        }
        
        listItem.innerHTML = `
          <div class="customer-list-drag-handle" title="Drag untuk mengubah urutan">‚ò∞</div>
          <div class="customer-list-info">
            <div class="customer-list-name">${customer.name || 'Tanpa Nama'}</div>
            <div class="customer-list-doc">${customer.docNo || '-'}</div>
            ${addressDisplay ? `<div class="customer-list-address">${addressDisplay}</div>` : ''}
          </div>
          <div class="customer-list-actions">
            <button type="button" class="secondary edit-customer-btn" data-type="${type}" data-index="${index}">‚úèÔ∏è Edit</button>
            <button type="button" class="secondary remove-customer-btn" data-type="${type}" data-index="${index}">üóëÔ∏è Hapus</button>
          </div>
        `;
        
        // Drag and Drop event handlers
        listItem.addEventListener('dragstart', (e) => {
          draggedIndex = index;
          listItem.classList.add('dragging');
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', index.toString());
        });
        
        listItem.addEventListener('dragend', (e) => {
          listItem.classList.remove('dragging');
          // Remove drag-over class from all items
          container.querySelectorAll('.customer-list-item').forEach(item => {
            item.classList.remove('drag-over');
          });
          draggedIndex = null;
        });
        
        listItem.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          
          const dragging = container.querySelector('.dragging');
          if (!dragging || dragging === listItem) return;
          
          const afterElement = getDragAfterElement(container, e.clientY);
          
          if (afterElement == null) {
            container.appendChild(dragging);
          } else {
            container.insertBefore(dragging, afterElement);
          }
          
          // Add drag-over class to current item if not dragging
          listItem.classList.add('drag-over');
        });
        
        listItem.addEventListener('dragleave', (e) => {
          listItem.classList.remove('drag-over');
        });
        
        listItem.addEventListener('drop', (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          // Remove drag-over class from all items
          container.querySelectorAll('.customer-list-item').forEach(item => {
            item.classList.remove('drag-over');
          });
          
          if (draggedIndex !== null && draggedIndex !== index) {
            // Get current order from DOM after drag
            const items = Array.from(container.querySelectorAll('.customer-list-item'));
            
            // Create a map of old index to customer data
            const customerMap = new Map();
            customersData[type].forEach((customer, idx) => {
              customerMap.set(idx, customer);
            });
            
            // Reorder berdasarkan urutan DOM (urutan aktual setelah drag)
            const reorderedCustomers = items.map(item => {
              const oldIndex = parseInt(item.dataset.index);
              return customerMap.get(oldIndex);
            }).filter(c => c !== undefined); // Filter undefined jika ada
            
            customersData[type] = reorderedCustomers;
            
            // Re-render list dengan urutan baru
            renderCustomerList(type);
          }
        });
        
        container.appendChild(listItem);
      });
      
      // Tambahkan event listener pada container untuk drop di area kosong
      container.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
      });
      
      container.addEventListener('drop', (e) => {
        e.preventDefault();
        if (draggedIndex !== null) {
          // Get current order from DOM
          const items = Array.from(container.querySelectorAll('.customer-list-item'));
          
          // Create a map of old index to customer data
          const customerMap = new Map();
          customersData[type].forEach((customer, idx) => {
            customerMap.set(idx, customer);
          });
          
          // Reorder berdasarkan urutan DOM
          const reorderedCustomers = items.map(item => {
            const oldIndex = parseInt(item.dataset.index);
            return customerMap.get(oldIndex);
          }).filter(c => c !== undefined);
          
          customersData[type] = reorderedCustomers;
          renderCustomerList(type);
        }
      });
      
      // Tambahkan event listeners untuk tombol edit dan hapus
      container.querySelectorAll('.edit-customer-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const type = e.target.getAttribute('data-type');
          const index = parseInt(e.target.getAttribute('data-index'));
          openCustomerModal(type, index);
        });
      });
      
      container.querySelectorAll('.remove-customer-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const type = e.target.getAttribute('data-type');
          const index = parseInt(e.target.getAttribute('data-index'));
          customersData[type].splice(index, 1);
          renderCustomerList(type);
        });
      });
    }

    // Fungsi untuk menyimpan customer dari modal
    function saveCustomerFromModal() {
      const activeTab = editingCustomerType || document.querySelector('.form-tab-btn.active').dataset.formTab;
      const customerType = activeTab;
      
      const name = dom.modalCustName().value.trim();
      const docNo = dom.modalCustDoc().value.trim();
      const notes = dom.modalCustNotes().value.trim();
      
      if (!name || !docNo) {
        showError('Nama dan Nomor Dokumen wajib diisi.');
        return;
      }
      
      let customerData;
      
      if (customerType === 'address') {
        const address = dom.modalCustAddr().value.trim();
        if (!address) {
          showError('Alamat customer wajib diisi.');
          return;
        }
        customerData = { name, docNo, address, notes };
      } else if (customerType === 'coordinates') {
        const lat = parseFloat(dom.modalCustLat().value.trim());
        const lng = parseFloat(dom.modalCustLng().value.trim());
        
        if (isNaN(lat) || isNaN(lng)) {
          showError('Latitude dan Longitude wajib diisi dengan angka yang valid.');
          return;
        }
        
        if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {
          showError('Koordinat tidak valid. Latitude harus antara -90 sampai 90, Longitude harus antara -180 sampai 180.');
          return;
        }
        
        customerData = { name, docNo, lat, lng, notes };
      } else if (customerType === 'hybrid') {
        // Untuk hybrid, cek apakah menggunakan alamat atau koordinat
        const hybridInputType = document.querySelector('input[name="hybridInputType"]:checked')?.value || 'address';
        
        if (hybridInputType === 'address') {
          const address = dom.modalCustAddr().value.trim();
          if (!address) {
            showError('Alamat customer wajib diisi.');
            return;
          }
          customerData = { name, docNo, address, notes };
        } else {
          const lat = parseFloat(dom.modalCustLat().value.trim());
          const lng = parseFloat(dom.modalCustLng().value.trim());
          
          if (isNaN(lat) || isNaN(lng)) {
            showError('Latitude dan Longitude wajib diisi dengan angka yang valid.');
            return;
          }
          
          if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {
            showError('Koordinat tidak valid. Latitude harus antara -90 sampai 90, Longitude harus antara -180 sampai 180.');
            return;
          }
          
          customerData = { name, docNo, lat, lng, notes };
        }
      }
      
      // Simpan atau update customer
      if (editingCustomerIndex !== null) {
        customersData[customerType][editingCustomerIndex] = customerData;
      } else {
        customersData[customerType].push(customerData);
      }
      
      // Render ulang list
      renderCustomerList(customerType);
      
      // Tutup modal
      closeCustomerModal();
      
      showSuccess('Customer berhasil disimpan.');
    }

    function addCustomerItem(prefill = { name: '', docNo: '', address: '', notes: '' }) {
      const wrapper = document.createElement('div');
      wrapper.className = 'customer-item';

      const nameId = 'custName-' + Math.random().toString(36).slice(2);
      const docId = 'custDoc-' + Math.random().toString(36).slice(2);
      const addrId = 'custAddr-' + Math.random().toString(36).slice(2);
      const notesId = 'custNotes-' + Math.random().toString(36).slice(2);

      wrapper.innerHTML = `
        <div class=\"row\">
          <label for=\"${nameId}\">Nama Customer</label>
          <input id=\"${nameId}\" type=\"text\" placeholder=\"Nama customer\" value=\"${prefill.name}\">
        </div>
        <div class=\"row\">
          <label for=\"${docId}\">Nomor Dokumen</label>
          <input id=\"${docId}\" type=\"text\" placeholder=\"Contoh: DO-2025-0001\" value=\"${prefill.docNo}\">
        </div>
        <div class=\"row\">
          <label for=\"${addrId}\">Alamat Customer</label>
          <input id=\"${addrId}\" type=\"text\" placeholder=\"Ketik alamat atau paste URL Google Maps...\" value=\"${prefill.address}\">
        </div>
        <div class=\"row\">
          <label for=\"${notesId}\">Notes</label>
          <input id=\"${notesId}\" type=\"text\" placeholder=\"Catatan tambahan (opsional)\" value=\"${prefill.notes || ''}\">
        </div>
        <div class=\"inline\" style=\"justify-content: flex-end;\">
          <button type=\"button\" class=\"secondary removeBtn\">Hapus</button>
        </div>
      `;

      const removeBtn = wrapper.querySelector('.removeBtn');
      const addrInput = wrapper.querySelector('#' + addrId);
      
      removeBtn.addEventListener('click', () => {
        const idx = customerAutocompletes.findIndex(x => x.input === addrInput);
        if (idx >= 0) customerAutocompletes.splice(idx, 1);
        wrapper.remove();
      });

      dom.customers().appendChild(wrapper);

      const autocomplete = new google.maps.places.Autocomplete(addrInput, {
        fields: ['geometry', 'formatted_address', 'name', 'address_components'],
        types: ['geocode'],
      });
      if (cityPlace && cityPlace.geometry && cityPlace.geometry.viewport) {
        autocomplete.setBounds(cityPlace.geometry.viewport);
        autocomplete.setOptions({ strictBounds: false });
      }
      customerAutocompletes.push(autocomplete);
    }

    // Fungsi untuk menambah customer dengan koordinat
    function addCustomerItemCoord(prefill = { name: '', docNo: '', lat: '', lng: '', notes: '' }) {
      const wrapper = document.createElement('div');
      wrapper.className = 'customer-item';

      const nameId = 'custCoordName-' + Math.random().toString(36).slice(2);
      const docId = 'custCoordDoc-' + Math.random().toString(36).slice(2);
      const latId = 'custCoordLat-' + Math.random().toString(36).slice(2);
      const lngId = 'custCoordLng-' + Math.random().toString(36).slice(2);
      const notesId = 'custCoordNotes-' + Math.random().toString(36).slice(2);

      wrapper.innerHTML = `
        <div class=\"row\">
          <label for=\"${nameId}\">Nama Customer</label>
          <input id=\"${nameId}\" type=\"text\" placeholder=\"Nama customer\" value=\"${prefill.name}\">
        </div>
        <div class=\"row\">
          <label for=\"${docId}\">Nomor Dokumen</label>
          <input id=\"${docId}\" type=\"text\" placeholder=\"Contoh: DO-2025-0001\" value=\"${prefill.docNo}\">
        </div>
        <div class=\"row\">
          <label for=\"${latId}\">Latitude</label>
          <input id=\"${latId}\" type=\"number\" step=\"any\" placeholder=\"-6.2088\" value=\"${prefill.lat}\">
        </div>
        <div class=\"row\">
          <label for=\"${lngId}\">Longitude</label>
          <input id=\"${lngId}\" type=\"number\" step=\"any\" placeholder=\"106.8456\" value=\"${prefill.lng}\">
        </div>
        <div class=\"row\">
          <label for=\"${notesId}\">Notes</label>
          <input id=\"${notesId}\" type=\"text\" placeholder=\"Catatan tambahan (opsional)\" value=\"${prefill.notes || ''}\">
        </div>
        <div class=\"inline\" style=\"justify-content: flex-end;\">
          <button type=\"button\" class=\"secondary removeBtn\">Hapus</button>
        </div>
      `;

      const removeBtn = wrapper.querySelector('.removeBtn');
      removeBtn.addEventListener('click', () => {
        wrapper.remove();
      });

      document.getElementById('customersCoord').appendChild(wrapper);
    }

    // Fungsi untuk download template Excel - Alamat Lengkap
    function downloadTemplateAddress() {
      const wb = XLSX.utils.book_new();
      
      // Header untuk template alamat lengkap
      const templateData = [
        ['Nama Customer', 'Nomor Dokumen', 'Alamat Customer', 'Notes'],
        ['Contoh Customer 1', 'DO-2025-0001', 'Jl. Sudirman No.1, Jakarta Pusat', 'Catatan contoh 1'],
        ['Contoh Customer 2', 'DO-2025-0002', 'Jl. Thamrin No.10, Jakarta Pusat', 'Catatan contoh 2'],
      ];
      
      const ws = XLSX.utils.aoa_to_sheet(templateData);
      
      // Set column widths
      ws['!cols'] = [
        { wch: 25 },  // Nama Customer
        { wch: 20 },  // Nomor Dokumen
        { wch: 50 },  // Alamat Customer
        { wch: 30 }   // Notes
      ];
      
      // Style header row
      const headerRange = XLSX.utils.decode_range(ws['!ref']);
      for (let col = headerRange.s.c; col <= headerRange.e.c; col++) {
        const headerCell = XLSX.utils.encode_cell({ r: 0, c: col });
        if (!ws[headerCell]) ws[headerCell] = { t: 's', v: '' };
        ws[headerCell].s = {
          fill: { fgColor: { rgb: '667EEA' } },
          font: { bold: true, color: { rgb: 'FFFFFF' } },
          alignment: { horizontal: 'center', vertical: 'center' }
        };
      }
      
      XLSX.utils.book_append_sheet(wb, ws, 'Template Customer');
      
      // Download file
      const fileName = `template-customer-alamat-${new Date().toISOString().split('T')[0]}.xlsx`;
      XLSX.writeFile(wb, fileName);
    }

    // Fungsi untuk download template Excel - Koordinat
    function downloadTemplateCoord() {
      const wb = XLSX.utils.book_new();
      
      // Header untuk template koordinat
      const templateData = [
        ['Nama Customer', 'Nomor Dokumen', 'Latitude', 'Longitude', 'Notes'],
        ['Contoh Customer 1', 'DO-2025-0001', -6.2088, 106.8456, 'Catatan contoh 1'],
        ['Contoh Customer 2', 'DO-2025-0002', -6.1944, 106.8229, 'Catatan contoh 2'],
      ];
      
      const ws = XLSX.utils.aoa_to_sheet(templateData);
      
      // Set column widths
      ws['!cols'] = [
        { wch: 25 },  // Nama Customer
        { wch: 20 },  // Nomor Dokumen
        { wch: 15 },  // Latitude
        { wch: 15 },  // Longitude
        { wch: 30 }   // Notes
      ];
      
      // Style header row
      const headerRange = XLSX.utils.decode_range(ws['!ref']);
      for (let col = headerRange.s.c; col <= headerRange.e.c; col++) {
        const headerCell = XLSX.utils.encode_cell({ r: 0, c: col });
        if (!ws[headerCell]) ws[headerCell] = { t: 's', v: '' };
        ws[headerCell].s = {
          fill: { fgColor: { rgb: '667EEA' } },
          font: { bold: true, color: { rgb: 'FFFFFF' } },
          alignment: { horizontal: 'center', vertical: 'center' }
        };
      }
      
      XLSX.utils.book_append_sheet(wb, ws, 'Template Customer');
      
      // Download file
      const fileName = `template-customer-koordinat-${new Date().toISOString().split('T')[0]}.xlsx`;
      XLSX.writeFile(wb, fileName);
    }

    // Fungsi untuk membaca dan memproses file Excel - Alamat Lengkap
    async function processUploadedAddressFile(file) {
      try {
        const data = await file.arrayBuffer();
        const workbook = XLSX.read(data, { type: 'array' });
        const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
        
        // Gunakan defval untuk menangani sel kosong
        const jsonData = XLSX.utils.sheet_to_json(firstSheet, { 
          header: 1, 
          defval: '',
          blankrows: false 
        });
        
        console.log('Excel data read:', jsonData);
        
        if (!jsonData || jsonData.length < 2) {
          showError('File Excel kosong atau tidak valid. Pastikan ada header dan minimal 1 baris data.');
          return;
        }
        
        // Skip header row (baris pertama)
        const rows = jsonData.slice(1);
        
        // Clear existing customers
        customersData.address = [];
        
        // Process each row
        let successCount = 0;
        let errorCount = 0;
        
        for (let i = 0; i < rows.length; i++) {
          const row = rows[i];
          
          // Skip baris kosong atau baris yang semua selnya kosong
          if (!row || row.length === 0) {
            continue;
          }
          
          // Pastikan array memiliki minimal 3 elemen (notes opsional)
          while (row.length < 4) {
            row.push('');
          }
          
          const name = String(row[0] || '').trim();
          const docNo = String(row[1] || '').trim();
          const address = String(row[2] || '').trim();
          const notes = String(row[3] || '').trim(); // Notes opsional
          
          // Skip jika semua field kosong (baris kosong)
          if (!name && !docNo && !address) {
            continue;
          }
          
          // Validasi: minimal harus ada nama dan nomor dokumen dan alamat
          if (!name || !docNo || !address) {
            errorCount++;
            console.log(`Baris ${i + 2} dilewati - Data tidak lengkap:`, { name, docNo, address });
            continue;
          }
          
          customersData.address.push({ name, docNo, address, notes });
          successCount++;
        }
        
        // Render ulang list
        renderCustomerList('address');
        
        if (successCount > 0) {
          showSuccess(`Berhasil mengimpor ${successCount} customer${successCount > 1 ? '' : ''}.${errorCount > 0 ? ` ${errorCount} baris dilewati karena data tidak lengkap.` : ''}`);
          setTimeout(() => clearError(), 5000);
        } else {
          showError(`Tidak ada data yang berhasil diimpor. ${errorCount > 0 ? `${errorCount} baris ditemukan tetapi data tidak lengkap.` : 'Pastikan format file sesuai template (Kolom: Nama Customer, Nomor Dokumen, Alamat Customer).'}`);
        }
        
      } catch (error) {
        console.error('Error processing file:', error);
        showError('Gagal membaca file Excel. Pastikan file tidak rusak dan format sesuai template. Error: ' + error.message);
      }
    }

    // Fungsi untuk membaca dan memproses file Excel - Koordinat
    async function processUploadedCoordFile(file) {
      try {
        const data = await file.arrayBuffer();
        const workbook = XLSX.read(data, { type: 'array' });
        const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
        
        // Gunakan defval untuk menangani sel kosong
        const jsonData = XLSX.utils.sheet_to_json(firstSheet, { 
          header: 1, 
          defval: '',
          blankrows: false 
        });
        
        console.log('Excel data read (coord):', jsonData);
        
        if (!jsonData || jsonData.length < 2) {
          showError('File Excel kosong atau tidak valid. Pastikan ada header dan minimal 1 baris data.');
          return;
        }
        
        // Skip header row (baris pertama)
        const rows = jsonData.slice(1);
        
        // Clear existing customers
        customersData.coordinates = [];
        
        // Process each row
        let successCount = 0;
        let errorCount = 0;
        
        for (let i = 0; i < rows.length; i++) {
          const row = rows[i];
          
          // Skip baris kosong atau baris yang semua selnya kosong
          if (!row || row.length === 0) {
            continue;
          }
          
          // Pastikan array memiliki minimal 5 elemen (notes opsional)
          while (row.length < 5) {
            row.push('');
          }
          
          const name = String(row[0] || '').trim();
          const docNo = String(row[1] || '').trim();
          const latStr = String(row[2] || '').trim();
          const lngStr = String(row[3] || '').trim();
          const notes = String(row[4] || '').trim(); // Notes opsional
          
          // Skip jika semua field kosong (baris kosong)
          if (!name && !docNo && !latStr && !lngStr) {
            continue;
          }
          
          // Parse koordinat
          const lat = parseFloat(latStr);
          const lng = parseFloat(lngStr);
          
          // Validasi: semua field harus terisi dan koordinat harus valid
          if (!name || !docNo || isNaN(lat) || isNaN(lng)) {
            errorCount++;
            console.log(`Baris ${i + 2} dilewati - Data tidak lengkap atau tidak valid:`, { name, docNo, lat, lng });
            continue;
          }
          
          // Validasi koordinat
          if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {
            errorCount++;
            console.log(`Baris ${i + 2} dilewati - Koordinat tidak valid:`, { lat, lng });
            continue;
          }
          
          customersData.coordinates.push({ name, docNo, lat, lng, notes });
          successCount++;
        }
        
        // Render ulang list
        renderCustomerList('coordinates');
        
        if (successCount > 0) {
          showSuccess(`Berhasil mengimpor ${successCount} customer${successCount > 1 ? '' : ''}.${errorCount > 0 ? ` ${errorCount} baris dilewati karena data tidak lengkap atau tidak valid.` : ''}`);
          setTimeout(() => clearError(), 5000);
        } else {
          showError(`Tidak ada data yang berhasil diimpor. ${errorCount > 0 ? `${errorCount} baris ditemukan tetapi data tidak lengkap atau tidak valid.` : 'Pastikan format file sesuai template (Kolom: Nama Customer, Nomor Dokumen, Latitude, Longitude).'}`);
        }
        
      } catch (error) {
        console.error('Error processing file:', error);
        showError('Gagal membaca file Excel. Pastikan file tidak rusak dan format sesuai template. Error: ' + error.message);
      }
    }

    // Fungsi untuk download template Excel - Hybrid
    function downloadTemplateHybrid() {
      const wb = XLSX.utils.book_new();
      
      // Header untuk template hybrid (bisa alamat ATAU koordinat)
      const templateData = [
        ['Nama Customer', 'Nomor Dokumen', 'Alamat Customer', 'Latitude', 'Longitude', 'Notes'],
        ['Contoh Customer 1', 'DO-2025-0001', 'Jl. Sudirman No.1, Jakarta Pusat', '', '', 'Catatan contoh 1'],
        ['Contoh Customer 2', 'DO-2025-0002', '', -6.2088, 106.8456, 'Catatan contoh 2'],
        ['Contoh Customer 3', 'DO-2025-0003', 'Jl. Thamrin No.10, Jakarta Pusat', '', '', 'Catatan contoh 3'],
      ];
      
      const ws = XLSX.utils.aoa_to_sheet(templateData);
      
      // Set column widths
      ws['!cols'] = [
        { wch: 25 },  // Nama Customer
        { wch: 20 },  // Nomor Dokumen
        { wch: 50 },  // Alamat Customer
        { wch: 15 },  // Latitude
        { wch: 15 },  // Longitude
        { wch: 30 }   // Notes
      ];
      
      // Style header row
      const headerRange = XLSX.utils.decode_range(ws['!ref']);
      for (let col = headerRange.s.c; col <= headerRange.e.c; col++) {
        const headerCell = XLSX.utils.encode_cell({ r: 0, c: col });
        if (!ws[headerCell]) ws[headerCell] = { t: 's', v: '' };
        ws[headerCell].s = {
          fill: { fgColor: { rgb: '667EEA' } },
          font: { bold: true, color: { rgb: 'FFFFFF' } },
          alignment: { horizontal: 'center', vertical: 'center' }
        };
      }
      
      XLSX.utils.book_append_sheet(wb, ws, 'Template Customer');
      
      // Download file
      const fileName = `template-customer-hybrid-${new Date().toISOString().split('T')[0]}.xlsx`;
      XLSX.writeFile(wb, fileName);
    }

    // Fungsi untuk membaca dan memproses file Excel - Hybrid
    async function processUploadedHybridFile(file) {
      try {
        const data = await file.arrayBuffer();
        const workbook = XLSX.read(data, { type: 'array' });
        const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
        
        // Gunakan defval untuk menangani sel kosong
        const jsonData = XLSX.utils.sheet_to_json(firstSheet, { 
          header: 1, 
          defval: '',
          blankrows: false 
        });
        
        console.log('Excel data read (hybrid):', jsonData);
        
        if (!jsonData || jsonData.length < 2) {
          showError('File Excel kosong atau tidak valid. Pastikan ada header dan minimal 1 baris data.');
          return;
        }
        
        // Skip header row (baris pertama)
        const rows = jsonData.slice(1);
        
        // Clear existing customers
        customersData.hybrid = [];
        
        // Process each row
        let successCount = 0;
        let errorCount = 0;
        
        for (let i = 0; i < rows.length; i++) {
          const row = rows[i];
          
          // Skip baris kosong atau baris yang semua selnya kosong
          if (!row || row.length === 0) {
            continue;
          }
          
          // Pastikan array memiliki minimal 6 elemen (notes opsional)
          while (row.length < 6) {
            row.push('');
          }
          
          const name = String(row[0] || '').trim();
          const docNo = String(row[1] || '').trim();
          const address = String(row[2] || '').trim();
          const latStr = String(row[3] || '').trim();
          const lngStr = String(row[4] || '').trim();
          const notes = String(row[5] || '').trim(); // Notes opsional
          
          // Skip jika semua field kosong (baris kosong)
          if (!name && !docNo && !address && !latStr && !lngStr) {
            continue;
          }
          
          // Validasi: minimal harus ada nama dan nomor dokumen
          if (!name || !docNo) {
            errorCount++;
            console.log(`Baris ${i + 2} dilewati - Nama atau Nomor Dokumen kosong:`, { name, docNo });
            continue;
          }
          
          // Harus punya alamat ATAU koordinat
          if (!address && (!latStr || !lngStr)) {
            errorCount++;
            console.log(`Baris ${i + 2} dilewati - Harus mengisi Alamat atau Koordinat:`, { address, latStr, lngStr });
            continue;
          }
          
          // Prioritas koordinat jika tersedia dan valid (lebih akurat)
          let useCoordinates = false;
          if (latStr && lngStr) {
            const lat = parseFloat(latStr);
            const lng = parseFloat(lngStr);
            
            // Cek apakah koordinat valid
            if (!isNaN(lat) && !isNaN(lng) && 
                lat >= -90 && lat <= 90 && 
                lng >= -180 && lng <= 180) {
              useCoordinates = true;
              
              // Simpan dengan koordinat (prioritas), tapi simpan juga alamat jika ada untuk referensi
              const customerData = { name, docNo, lat, lng, notes };
              if (address && address.trim()) {
                customerData.address = address; // Simpan alamat juga untuk referensi
              }
              customersData.hybrid.push(customerData);
            } else {
              // Koordinat tidak valid, akan fallback ke alamat
              console.log(`Baris ${i + 2} - Koordinat tidak valid, menggunakan alamat sebagai fallback:`, { latStr, lngStr });
            }
          }
          
          // Jika koordinat tidak digunakan (kosong atau tidak valid), gunakan alamat
          if (!useCoordinates && address && address.trim()) {
            customersData.hybrid.push({ name, docNo, address, notes });
          } else if (!useCoordinates && !address) {
            // Jika koordinat tidak valid dan alamat juga kosong, skip baris ini
            errorCount++;
            console.log(`Baris ${i + 2} dilewati - Koordinat tidak valid dan alamat kosong:`, { latStr, lngStr, address });
            continue;
          }
          
          successCount++;
        }
        
        // Render ulang list
        renderCustomerList('hybrid');
        
        if (successCount > 0) {
          showSuccess(`Berhasil mengimpor ${successCount} customer${successCount > 1 ? '' : ''}.${errorCount > 0 ? ` ${errorCount} baris dilewati karena data tidak lengkap atau tidak valid.` : ''}`);
          setTimeout(() => clearError(), 5000);
        } else {
          showError(`Tidak ada data yang berhasil diimpor. ${errorCount > 0 ? `${errorCount} baris ditemukan tetapi data tidak lengkap atau tidak valid.` : 'Pastikan format file sesuai template (Kolom: Nama Customer, Nomor Dokumen, Alamat Customer ATAU Latitude+Longitude).'}`);
        }
        
      } catch (error) {
        console.error('Error processing file:', error);
        showError('Gagal membaca file Excel. Pastikan file tidak rusak dan format sesuai template. Error: ' + error.message);
      }
    }

    function toggleStoreLock() {
      isStoreLocked = !isStoreLocked;
      dom.storeAddress().disabled = isStoreLocked;
      dom.lockStoreBtn().textContent = isStoreLocked ? 'Unlock' : 'Kunci';
      dom.lockStoreBtn().setAttribute('aria-pressed', String(isStoreLocked));
    }

    function clearMarkers() {
      customMarkers.forEach(m => m.setMap(null));
      customMarkers = [];
    }

    function clearPolylines() {
      customPolylines.forEach(p => p.setMap(null));
      customPolylines = [];
    }

    function clearTruckAnimation() {
      if (truckMarker) {
        truckMarker.setMap(null);
        truckMarker = null;
      }
      if (animationInterval) {
        clearInterval(animationInterval);
        animationInterval = null;
      }
    }

    function createTruckMarker(position) {
      return new google.maps.Marker({
        position: position,
        map: map,
        icon: {
          url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(`
            <svg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
              <circle cx="20" cy="20" r="18" fill="#3b82f6" stroke="#fff" stroke-width="2"/>
              <path d="M12 15h16v8h-2v-6H14v6h-2v-8z" fill="#fff"/>
              <circle cx="16" cy="26" r="3" fill="#1e40af"/>
              <circle cx="24" cy="26" r="3" fill="#1e40af"/>
              <path d="M10 18h2v2h-2z" fill="#fff"/>
              <path d="M28 18h2v2h-2z" fill="#fff"/>
            </svg>
          `),
          scaledSize: new google.maps.Size(40, 40),
          anchor: new google.maps.Point(20, 20)
        },
        zIndex: 1000
      });
    }

    function animateTruckAlongRoute(route) {
      clearTruckAnimation();
      
      const path = route.overview_path;
      if (!path || path.length < 2) return;

      let currentIndex = 0;
      const totalPoints = path.length;
      const animationDuration = 10000; // 10 detik
      const intervalTime = 50; // Update setiap 50ms
      const totalSteps = animationDuration / intervalTime;
      const stepSize = totalPoints / totalSteps;

      truckMarker = createTruckMarker(path[0]);

      animationInterval = setInterval(() => {
        currentIndex += stepSize;
        
        if (currentIndex >= totalPoints - 1) {
          // Animasi selesai
          clearInterval(animationInterval);
          animationInterval = null;
          // Pindahkan truk ke posisi terakhir
          truckMarker.setPosition(path[totalPoints - 1]);
          return;
        }

        const currentPoint = path[Math.floor(currentIndex)];
        truckMarker.setPosition(currentPoint);

        // Hitung rotasi berdasarkan arah gerakan
        if (currentIndex > 0) {
          const prevPoint = path[Math.floor(currentIndex - stepSize)];
          const heading = google.maps.geometry.spherical.computeHeading(prevPoint, currentPoint);
          truckMarker.setIcon({
            url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(`
              <svg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
                <g transform="rotate(${heading} 20 20)">
                  <circle cx="20" cy="20" r="18" fill="#3b82f6" stroke="#fff" stroke-width="2"/>
                  <path d="M12 15h16v8h-2v-6H14v6h-2v-8z" fill="#fff"/>
                  <circle cx="16" cy="26" r="3" fill="#1e40af"/>
                  <circle cx="24" cy="26" r="3" fill="#1e40af"/>
                  <path d="M10 18h2v2h-2z" fill="#fff"/>
                  <path d="M28 18h2v2h-2z" fill="#fff"/>
                </g>
              </svg>
            `),
            scaledSize: new google.maps.Size(40, 40),
            anchor: new google.maps.Point(20, 20)
          });
        }
      }, intervalTime);
    }

    function placeMarker(position, label) {
      const marker = new google.maps.Marker({
        position,
        map,
        title: label,
        animation: google.maps.Animation.DROP,
        icon: {
          url: 'https://maps.gstatic.com/mapfiles/api-3/images/spotlight-poi2_hdpi.png',
          scaledSize: new google.maps.Size(32, 32),
        },
      });
      marker.addListener('mouseover', () => {
        infoWindow.setContent('<div style="font-size:13px;font-weight:600;max-width:220px;">' + label + '</div>');
        infoWindow.open({ anchor: marker, map });
      });
      marker.addListener('mouseout', () => {
        infoWindow.close();
      });
      customMarkers.push(marker);
      return marker;
    }

    function parseLatLngFromUrl(url) {
      try {
        const atMatch = url.match(/@(-?\d+\.\d+),(-?\d+\.\d+)/);
        if (atMatch) {
          return new google.maps.LatLng(parseFloat(atMatch[1]), parseFloat(atMatch[2]));
        }
        const u = new URL(url);
        const q = u.searchParams.get('q') || u.searchParams.get('query');
        if (q) return q;
      } catch (_) {}
      return null;
    }

    // Fungsi untuk mendapatkan origin store dengan prioritas koordinat dari database
    async function getStoreOrigin() {
      // Jika toko dipilih dari database dan memiliki koordinat, gunakan koordinat tersebut
      if (selectedStoreData && selectedStoreData.latitude && selectedStoreData.longitude) {
        const location = new google.maps.LatLng(selectedStoreData.latitude, selectedStoreData.longitude);
        return {
          location: location,
          formatted: selectedStoreData.address
        };
      }
      
      // Jika tidak, gunakan geocoding seperti biasa
      return await getPlaceOrGeocode(dom.storeAddress(), storeAutocomplete);
    }

    async function getPlaceOrGeocode(inputEl, autocompleteInstance) {
      const value = inputEl.value.trim();
      const place = autocompleteInstance && autocompleteInstance.getPlace ? autocompleteInstance.getPlace() : null;
      if (place && place.geometry) return { location: place.geometry.location, formatted: place.formatted_address || value };

      if (!value) throw new Error('Alamat kosong');

      const parsed = parseLatLngFromUrl(value);
      if (parsed instanceof google.maps.LatLng) {
        return { location: parsed, formatted: value };
      }

      const addressToGeocode = typeof parsed === 'string' ? parsed : (cityPlace ? (value + ', ' + (cityPlace.formatted_address || '')) : value);
      const geocodeResp = await geocoder.geocode({ address: addressToGeocode, region: 'id', bounds: cityPlace?.geometry?.viewport });
      if (!geocodeResp.results || geocodeResp.results.length === 0) throw new Error('Alamat tidak ditemukan: ' + value);
      const best = geocodeResp.results[0];
      return { location: best.geometry.location, formatted: best.formatted_address };
    }

    function distanceMatrix(origins, destinations) {
      return new Promise((resolve, reject) => {
        distanceMatrixService.getDistanceMatrix({
          origins,
          destinations,
          travelMode: google.maps.TravelMode.DRIVING,
        }, (res, status) => {
          if (status !== 'OK') return reject(new Error(status));
          resolve(res);
        });
      });
    }

    async function computeNearestOrder(originLatLng, customerLatLngs) {
      const remaining = customerLatLngs.map((ll, idx) => ({ idx, ll }));
      const order = [];
      let current = originLatLng;
      while (remaining.length > 0) {
        const dests = remaining.map(r => r.ll);
        let dm;
        try {
          dm = await distanceMatrix([current], dests);
        } catch (e) {
          throw new Error('REQUEST_DENIED');
        }
        const row = dm.rows[0].elements;
        let bestIdx = 0; let bestVal = Infinity;
        for (let i = 0; i < row.length; i++) {
          const el = row[i];
          const val = el.status === 'OK' ? el.distance.value : Infinity;
          if (val < bestVal) { bestVal = val; bestIdx = i; }
        }
        const chosen = remaining.splice(bestIdx, 1)[0];
        order.push(chosen.idx);
        current = chosen.ll;
      }
      return order;
    }

    function buildWaypointsFromOrder(resolvedCustomers, order) {
      return order.map(i => ({ location: resolvedCustomers[i].location, stopover: true }));
    }



    async function rerenderWithOrder(resolvedCustomers, order) {
      try {
        const storeResolved = await getStoreOrigin();
        const origin = storeResolved.location;
        const waypoints = buildWaypointsFromOrder(resolvedCustomers, order);
        const request = {
          origin,
          destination: origin,
          travelMode: google.maps.TravelMode.DRIVING,
          provideRouteAlternatives: false,
          optimizeWaypoints: false,
          waypoints,
        };
        // Siapkan informasi customer untuk error handling
        const customerInfo = {
          customers: resolvedCustomers,
          order: order,
          startIndex: 0
        };
        const response = await getDirections(request, customerInfo);
        renderRoute(response, { geometry: { location: origin }, formatted_address: storeResolved.formatted }, order, resolvedCustomers);
        renderDropList(order, resolvedCustomers);
        renderDesktopDropTable(order, resolvedCustomers);
      } catch (err) {
        console.error(err);
        const errorMsg = err.message || 'Gagal merender ulang rute.';
        showError(errorMsg);
      }
    }

    async function processRoute() {
      clearError();

      const storeVal = dom.storeAddress().value.trim();
      if (!storeVal) {
        showError('Alamat toko (origin) wajib diisi.');
        return;
      }

      // Deteksi tab aktif
      const activeTab = document.querySelector('.form-tab-btn.active').dataset.formTab;
      let customerItems = [];
      let resolvedCustomers = [];

      if (activeTab === 'address') {
        // Mode alamat lengkap - baca dari customersData
        const customersInput = customersData.address.filter(c => c.address);

        if (customersInput.length === 0) {
          showError('Tambahkan minimal 1 customer dengan alamat yang valid.');
          return;
        }
        const missingDoc = customersInput.find(c => !c.docNo);
        if (missingDoc) {
          showError('Nomor dokumen wajib diisi untuk setiap customer.');
          return;
        }

        dom.processBtn().disabled = true;
        dom.processBtn().textContent = 'Memproses...';
        showLoading();

        try {
          const originResolved = await getStoreOrigin();
          const origin = originResolved.location;

          // Geocode setiap customer dari customersData
          for (let i = 0; i < customersInput.length; i++) {
            const customer = customersInput[i];
            // Buat input dummy untuk geocoding
            const dummyInput = document.createElement('input');
            dummyInput.value = customer.address;
            const resolved = await getPlaceOrGeocode(dummyInput, null);
            resolvedCustomers.push({
              name: customer.name,
              docNo: customer.docNo,
              formatted: resolved.formatted,
              location: resolved.location,
              notes: customer.notes || '',
            });
          }

          await processRouteWithCustomers(origin, originResolved.formatted, resolvedCustomers);
        } catch (err) {
          console.error(err);
          showError(err.message || 'Gagal menghitung rute. Periksa input dan API key.');
        } finally {
          hideLoading();
          dom.processBtn().disabled = false;
          dom.processBtn().textContent = 'Proses Rute';
        }
      } else if (activeTab === 'coordinates') {
        // Mode koordinat - baca dari customersData
        const customersInput = customersData.coordinates.filter(c => !isNaN(c.lat) && !isNaN(c.lng) && c.lat !== 0 && c.lng !== 0);

        if (customersInput.length === 0) {
          showError('Tambahkan minimal 1 customer dengan koordinat yang valid.');
          return;
        }
        const missingDoc = customersInput.find(c => !c.docNo);
        if (missingDoc) {
          showError('Nomor dokumen wajib diisi untuk setiap customer.');
          return;
        }

        // Validasi koordinat
        const invalidCoord = customersInput.find(c => c.lat < -90 || c.lat > 90 || c.lng < -180 || c.lng > 180);
        if (invalidCoord) {
          showError('Koordinat tidak valid. Latitude harus antara -90 sampai 90, Longitude harus antara -180 sampai 180.');
          return;
        }

        dom.processBtn().disabled = true;
        dom.processBtn().textContent = 'Memproses...';
        showLoading();

        try {
          const originResolved = await getStoreOrigin();
          const origin = originResolved.location;

          // Geocode koordinat untuk mendapatkan alamat lengkap
          for (let i = 0; i < customersInput.length; i++) {
            const customer = customersInput[i];
            const location = new google.maps.LatLng(customer.lat, customer.lng);
            
            // Reverse geocode untuk mendapatkan alamat
            const geocodeResp = await new Promise((resolve, reject) => {
              geocoder.geocode({ location: location }, (results, status) => {
                if (status === 'OK' && results[0]) {
                  resolve(results[0]);
                } else {
                  reject(new Error('Gagal mendapatkan alamat untuk koordinat: ' + customer.lat + ', ' + customer.lng));
                }
              });
            });

            resolvedCustomers.push({
              name: customer.name,
              docNo: customer.docNo,
              formatted: geocodeResp.formatted_address || `${customer.lat}, ${customer.lng}`,
              location: location,
              notes: customer.notes || '',
            });
          }

          await processRouteWithCustomers(origin, originResolved.formatted, resolvedCustomers);
        } catch (err) {
          console.error(err);
          showError(err.message || 'Gagal menghitung rute. Periksa input dan API key.');
        } finally {
          hideLoading();
          dom.processBtn().disabled = false;
          dom.processBtn().textContent = 'Proses Rute';
        }
      } else if (activeTab === 'hybrid') {
        // Mode hybrid - baca dari customersData.hybrid
        const customersInput = customersData.hybrid.filter(c => {
          // Harus punya alamat ATAU koordinat yang valid
          return (c.address && c.address.trim()) || 
                 (!isNaN(c.lat) && !isNaN(c.lng) && c.lat !== 0 && c.lng !== 0);
        });

        if (customersInput.length === 0) {
          showError('Tambahkan minimal 1 customer dengan alamat atau koordinat yang valid.');
          return;
        }
        const missingDoc = customersInput.find(c => !c.docNo);
        if (missingDoc) {
          showError('Nomor dokumen wajib diisi untuk setiap customer.');
          return;
        }

        // Validasi koordinat jika ada
        const invalidCoord = customersInput.find(c => 
          c.lat !== undefined && c.lng !== undefined && 
          (c.lat < -90 || c.lat > 90 || c.lng < -180 || c.lng > 180)
        );
        if (invalidCoord) {
          showError('Koordinat tidak valid. Latitude harus antara -90 sampai 90, Longitude harus antara -180 sampai 180.');
          return;
        }

        dom.processBtn().disabled = true;
        dom.processBtn().textContent = 'Memproses...';
        showLoading();

        try {
          const originResolved = await getStoreOrigin();
          const origin = originResolved.location;

          // Process setiap customer - prioritas koordinat jika tersedia
          for (let i = 0; i < customersInput.length; i++) {
            const customer = customersInput[i];
            
            // Prioritas 1: Gunakan koordinat jika tersedia dan valid (lebih akurat)
            if (!isNaN(customer.lat) && !isNaN(customer.lng) && 
                customer.lat >= -90 && customer.lat <= 90 && 
                customer.lng >= -180 && customer.lng <= 180) {
              // Menggunakan koordinat
              const location = new google.maps.LatLng(customer.lat, customer.lng);
              
              // Reverse geocode untuk mendapatkan alamat
              const geocodeResp = await new Promise((resolve, reject) => {
                geocoder.geocode({ location: location }, (results, status) => {
                  if (status === 'OK' && results[0]) {
                    resolve(results[0]);
                  } else {
                    reject(new Error('Gagal mendapatkan alamat untuk koordinat: ' + customer.lat + ', ' + customer.lng));
                  }
                });
              });

              resolvedCustomers.push({
                name: customer.name,
                docNo: customer.docNo,
                formatted: geocodeResp.formatted_address || `${customer.lat}, ${customer.lng}`,
                location: location,
                notes: customer.notes || '',
                // Simpan koordinat asli untuk referensi
                originalLat: customer.lat,
                originalLng: customer.lng
              });
            } else if (customer.address && customer.address.trim()) {
              // Prioritas 2: Gunakan alamat jika koordinat tidak tersedia
              const dummyInput = document.createElement('input');
              dummyInput.value = customer.address;
              const resolved = await getPlaceOrGeocode(dummyInput, null);
              resolvedCustomers.push({
                name: customer.name,
                docNo: customer.docNo,
                formatted: resolved.formatted,
                location: resolved.location,
                notes: customer.notes || '',
              });
            }
          }

          await processRouteWithCustomers(origin, originResolved.formatted, resolvedCustomers);
        } catch (err) {
          console.error(err);
          showError(err.message || 'Gagal menghitung rute. Periksa input dan API key.');
        } finally {
          hideLoading();
          dom.processBtn().disabled = false;
          dom.processBtn().textContent = 'Proses Rute';
        }
      }
    }

    // Fungsi helper untuk memproses rute dengan customers yang sudah di-resolve
    // Mendukung hingga 30 customer dengan membagi menjadi batch jika > 25 waypoints
    async function processRouteWithCustomers(origin, originFormatted, resolvedCustomers) {
      const MAX_WAYPOINTS = 25; // Batasan Google Maps Directions API
      const customerLatLngs = resolvedCustomers.map(c => c.location);
      let order;
      
      try {
        order = await computeNearestOrder(origin, customerLatLngs);
      } catch (e) {
        if (e && e.message === 'REQUEST_DENIED') {
          console.warn('Distance Matrix ditolak. Menggunakan urutan input.');
          order = customerLatLngs.map((_, i) => i);
          showError('Distance Matrix ditolak API Key. Urutan otomatis dinonaktifkan. Periksa pengaturan API (aktifkan Distance Matrix API atau perbaiki restriction).');
        } else {
          throw e;
        }
      }

      // Jika customer <= 25, proses seperti biasa
      if (resolvedCustomers.length <= MAX_WAYPOINTS) {
        const waypoints = buildWaypointsFromOrder(resolvedCustomers, order);
        const request = {
          origin,
          destination: origin,
          travelMode: google.maps.TravelMode.DRIVING,
          provideRouteAlternatives: false,
          optimizeWaypoints: false,
          waypoints,
        };

        try {
          // Siapkan informasi customer untuk error handling
          const customerInfo = {
            customers: resolvedCustomers,
            order: order,
            startIndex: 0
          };
          const response = await getDirections(request, customerInfo);
          renderRoute(response, { geometry: { location: origin }, formatted_address: originFormatted }, order, resolvedCustomers);
        } catch (directionsError) {
          console.error('Error in getDirections:', directionsError);
          showError(directionsError.message);
          throw directionsError;
        }
      } else {
        // Jika customer > 25, bagi menjadi beberapa batch
        await processRouteWithBatches(origin, originFormatted, resolvedCustomers, order, MAX_WAYPOINTS);
      }
    }

    // Fungsi untuk memproses rute dengan multiple batches (untuk > 25 customer)
    async function processRouteWithBatches(origin, originFormatted, resolvedCustomers, order, maxWaypoints) {
      // Bagi order menjadi batch-batch
      const batches = [];
      for (let i = 0; i < order.length; i += maxWaypoints) {
        batches.push(order.slice(i, i + maxWaypoints));
      }

      const allLegs = [];
      const allDropPoints = [];
      let totalMeters = 0;
      let totalSeconds = 0;
      let currentDropIndex = 0;

      // Proses setiap batch
      for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
        const batchOrder = batches[batchIndex];
        const batchCustomers = batchOrder.map(idx => resolvedCustomers[idx]);
        const waypoints = batchCustomers.map(c => ({ location: c.location, stopover: true }));

        // Untuk batch pertama, origin adalah toko
        // Untuk batch selanjutnya, origin adalah customer terakhir dari batch sebelumnya
        let batchOrigin = origin;
        if (batchIndex > 0) {
          // Origin batch ini adalah customer terakhir dari batch sebelumnya
          const prevBatchLastIdx = batches[batchIndex - 1][batches[batchIndex - 1].length - 1];
          batchOrigin = resolvedCustomers[prevBatchLastIdx].location;
        }

        // Destination: untuk batch terakhir kembali ke toko, untuk batch lain ke customer terakhir batch ini
        let batchDestination = origin; // Selalu kembali ke toko di akhir
        let batchWaypoints = waypoints;

        // Jika bukan batch terakhir, destination adalah customer terakhir batch ini
        // dan waypoint terakhir tidak perlu karena sudah jadi destination
        if (batchIndex < batches.length - 1) {
          batchDestination = batchCustomers[batchCustomers.length - 1].location;
          batchWaypoints = waypoints.slice(0, -1); // Hapus waypoint terakhir
        }

        // Simpan offset global untuk batch ini (sebelum increment)
        const batchGlobalOffset = currentDropIndex;

        const request = {
          origin: batchOrigin,
          destination: batchDestination,
          travelMode: google.maps.TravelMode.DRIVING,
          provideRouteAlternatives: false,
          optimizeWaypoints: false,
          waypoints: batchWaypoints,
        };

        try {
          // Siapkan informasi customer untuk error handling
          const customerInfo = {
            customers: resolvedCustomers,
            order: batchOrder,
            startIndex: batchGlobalOffset
          };
          const response = await getDirections(request, customerInfo);
          const route = response.routes[0];
          const legs = route.legs;

          // Tambahkan legs ke allLegs
          legs.forEach((leg, legIndex) => {
            allLegs.push(leg);
            totalMeters += leg.distance?.value || 0;
            totalSeconds += leg.duration?.value || 0;
          });

          // Tambahkan drop points untuk batch ini
          batchOrder.forEach((custIndex, idx) => {
            const c = resolvedCustomers[custIndex];
            allDropPoints.push({
              name: c.name || ('Customer ' + (currentDropIndex + 1)),
              docNo: c.docNo,
              address: c.formatted,
              notes: c.notes || '',
              latitude: c.location.lat(),
              longitude: c.location.lng(),
              batchNumber: batchIndex + 1
            });
            currentDropIndex++;
          });

          // Render batch route di peta
          renderBatchRoute(route, batchIndex, batchCustomers, batchOrder, resolvedCustomers, origin, originFormatted, batchGlobalOffset);
        } catch (error) {
          console.error(`Error processing batch ${batchIndex + 1}:`, error);
          // Tambahkan informasi batch ke error message
          const batchInfo = `\n\nüìç Informasi Batch yang Error:\n`;
          const batchInfoDetail = `- Batch: ${batchIndex + 1} dari ${batches.length}\n`;
          const batchInfoRange = `- Customer: ${batchGlobalOffset + 1} sampai ${batchGlobalOffset + batchOrder.length}\n`;
          const batchInfoList = batchOrder.map((idx, i) => {
            const c = resolvedCustomers[idx];
            return `  ${i + 1}. ${c.name || 'Tanpa Nama'} (${c.docNo}) - ${c.formatted}`;
          }).join('\n');
          
          const enhancedError = new Error(
            `Gagal memproses batch ${batchIndex + 1} dari ${batches.length}:\n\n${error.message}${batchInfo}${batchInfoDetail}${batchInfoRange}\nDaftar Customer di Batch ini:\n${batchInfoList}`
          );
          throw enhancedError;
        }
      }

      // Simpan data rute gabungan untuk download
      currentRouteData = {
        storeAddress: originFormatted || 'Origin',
        legs: allLegs,
        totalDistance: formatDistance(totalMeters),
        totalDuration: formatDuration(totalSeconds),
        dropPoints: allDropPoints
      };

      // Tampilkan button ringkasan rute
      dom.summaryButtonContainer().classList.remove('hidden');

      // Fit bounds untuk semua marker
      const bounds = new google.maps.LatLngBounds();
      bounds.extend(origin);
      resolvedCustomers.forEach(c => bounds.extend(c.location));
      map.fitBounds(bounds);

      // Scroll ke map setelah rute dirender
      setTimeout(() => {
        const mapElement = document.getElementById('map');
        if (mapElement) {
          mapElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      }, 300);

      showSuccess(`Rute berhasil diproses untuk ${resolvedCustomers.length} customer (dibagi menjadi ${batches.length} batch).`);
    }

    // Fungsi untuk render batch route di peta
    function renderBatchRoute(route, batchIndex, batchCustomers, batchOrder, resolvedCustomers, origin, originFormatted, globalOffset) {
      // Place marker untuk origin jika batch pertama
      if (batchIndex === 0) {
        const originPos = origin;
        placeMarker(originPos, 'Toko: ' + (originFormatted || 'Origin'));
      }

      // Place markers untuk customers di batch ini
      batchOrder.forEach((custIndex, idx) => {
        const c = resolvedCustomers[custIndex];
        const globalIndex = globalOffset + idx;
        placeMarker(c.location, `Drop ${globalIndex + 1}: ${c.name || ('Customer ' + (globalIndex + 1))} ‚Äî ${c.docNo} ‚Äî ${c.formatted}`);
      });

      // Render polyline untuk batch ini dengan warna berbeda
      const legs = route.legs;
      for (let i = 0; i < legs.length; i++) {
        const leg = legs[i];
        const path = [];
        leg.steps.forEach(s => {
          s.path.forEach(p => path.push(p));
        });
        
        // Gunakan warna berbeda untuk setiap batch
        const batchColors = [
          '#1e88e5', '#43a047', '#f4511e', '#8e24aa', '#fb8c00',
          '#3949ab', '#00acc1', '#6d4c41', '#e53935', '#7cb342'
        ];
        const color = batchColors[batchIndex % batchColors.length];
        
        const poly = new google.maps.Polyline({
          path,
          strokeColor: color,
          strokeOpacity: 0.9,
          strokeWeight: 5,
          map,
          icons: [{
            icon: { path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW },
            offset: '100%',
          }],
        });
        
        // Animasi polyline dengan delay berdasarkan batch
        poly.setOptions({ strokeOpacity: 0 });
        setTimeout(() => poly.setOptions({ strokeOpacity: 0.9 }), 200 + (batchIndex * 500) + (i * 150));
        customPolylines.push(poly);
      }
    }

    function renderRoute(result, originPlaceLike, order, resolvedCustomers) {
      directionsRenderer.set('directions', null);
      const route = result.routes[0];
      const legs = route.legs;
      clearMarkers();
      clearPolylines();
      const originPos = originPlaceLike.geometry.location;
      placeMarker(originPos, 'Toko: ' + (originPlaceLike.formatted_address || 'Origin'));
      order.forEach((custIndex, idx) => {
        const c = resolvedCustomers[custIndex];
        placeMarker(c.location, 'Drop ' + (idx+1) + ': ' + (c.name || ('Customer ' + (idx+1))) + ' ‚Äî ' + c.docNo + ' ‚Äî ' + c.formatted);
      });

      // Simpan data rute untuk download
      let totalMeters = 0;
      let totalSeconds = 0;
      legs.forEach(leg => {
        totalMeters += leg.distance?.value || 0;
        totalSeconds += leg.duration?.value || 0;
      });

      currentRouteData = {
        storeAddress: originPlaceLike.formatted_address || 'Origin',
        legs: legs,
        totalDistance: formatDistance(totalMeters),
        totalDuration: formatDuration(totalSeconds),
        dropPoints: order.map((custIndex, idx) => {
          const c = resolvedCustomers[custIndex];
          const dropPoint = {
            name: c.name || ('Customer ' + (idx+1)),
            docNo: c.docNo,
            address: c.formatted,
            notes: c.notes || ''
          };
          // Simpan koordinat asli jika tersedia (untuk tab koordinat)
          if (c.location && c.location.lat && c.location.lng) {
            dropPoint.latitude = c.location.lat();
            dropPoint.longitude = c.location.lng();
          }
          return dropPoint;
        })
      };
      
      // Render polyline untuk peta
      for (let i = 0; i < legs.length; i++) {
        const leg = legs[i];
        const path = [];
        leg.steps.forEach(s => {
          s.path.forEach(p => path.push(p));
        });
        const color = ROUTE_COLORS[i % ROUTE_COLORS.length];
        const poly = new google.maps.Polyline({
          path,
          strokeColor: color,
          strokeOpacity: 0.9,
          strokeWeight: 5,
          map,
          icons: [{
            icon: { path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW },
            offset: '100%',
          }],
        });
        // Animasi polyline
        poly.setOptions({ strokeOpacity: 0 });
        setTimeout(() => poly.setOptions({ strokeOpacity: 0.9 }), 200 + i * 150);
        customPolylines.push(poly);
      }

      // Tampilkan button ringkasan rute
      dom.summaryButtonContainer().classList.remove('hidden');

      const bounds = new google.maps.LatLngBounds();
      route.overview_path.forEach(p => bounds.extend(p));
      map.fitBounds(bounds);

      // Scroll ke map setelah rute dirender
      setTimeout(() => {
        const mapElement = document.getElementById('map');
        if (mapElement) {
          mapElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      }, 300);

      // Mulai animasi truk setelah polyline selesai di-render
      setTimeout(() => {
        animateTruckAlongRoute(route);
      }, 1000);
    }


    function resetAll() {
      clearError();
      dom.storeSelect().value = '';
      dom.cityInput().value = '';
      dom.storeAddress().value = '';
      // Reset alamat toko ke mode manual input
      dom.storeAddress().disabled = false;
      dom.storeAddress().placeholder = 'Ketik alamat atau paste URL Google Maps...';
      dom.storeAddress().style.backgroundColor = '#fff';
      dom.storeAddress().style.cursor = 'text';
      if (isStoreLocked) toggleStoreLock();
      // Reset customersData
      customersData = {
        address: [],
        coordinates: [],
        hybrid: []
      };
      // Reset ke tab hybrid (default)
      switchFormTab('hybrid');
      // Render ulang list customer (akan menampilkan pesan kosong)
      renderCustomerList('address');
      renderCustomerList('coordinates');
      renderCustomerList('hybrid');
      dom.summaryButtonContainer().classList.add('hidden');
      clearMarkers();
      clearPolylines();
      clearTruckAnimation();
      directionsRenderer.set('directions', null);
      cityPlace = null;
      currentRouteData = null;
      selectedStoreData = null; // Reset selected store data
      // Reset customer autocompletes
      customerAutocompletes = [];
    }

    // Fungsi untuk download PDF
    function downloadPDF() {
      if (!currentRouteData) {
        showError('Tidak ada data rute untuk didownload. Silakan proses rute terlebih dahulu.');
        return;
      }

      const { jsPDF } = window.jspdf;
      const doc = new jsPDF('p', 'mm', 'a4'); // A4 portrait
      
      // Konstanta untuk A4
      const pageWidth = 210; // A4 width in mm
      const pageHeight = 297; // A4 height in mm
      const margin = 15;
      const contentWidth = pageWidth - (margin * 2);
      
      // Header dengan background
      doc.setFillColor(102, 126, 234);
      doc.rect(0, 0, pageWidth, 25, 'F');
      
      // Judul utama
      doc.setTextColor(255, 255, 255);
      doc.setFontSize(18);
      doc.setFont(undefined, 'bold');
      doc.text('RINGKASAN RUTE PENGIRIMAN', margin, 15);
      
      // Tanggal dan waktu (di atas kanan)
      doc.setTextColor(0, 0, 0);
      doc.setFontSize(9);
      doc.setFont(undefined, 'normal');
      doc.text(`Dibuat: ${new Date().toLocaleString('id-ID')}`, pageWidth - margin - 50, 30);
      
      // Informasi toko
      doc.setFontSize(11);
      doc.setFont(undefined, 'bold');
      
      // Wrap text jika alamat terlalu panjang
      const maxWidth = pageWidth - margin - 25;
      const addressLines = doc.splitTextToSize(currentRouteData.storeAddress, maxWidth);
      doc.text(addressLines, margin, 35);
      
      // Garis pemisah
      doc.setDrawColor(200, 200, 200);
      doc.setLineWidth(0.5);
      const addressHeight = addressLines.length * 4; // Estimasi tinggi text
      const separatorY = 40 + addressHeight;
      doc.line(margin, separatorY, pageWidth - margin, separatorY);
      
      let currentY = separatorY + 10;
      
      // Ringkasan rute
      doc.setFontSize(14);
      doc.setFont(undefined, 'bold');
      doc.setTextColor(102, 126, 234);
      doc.text('RINGKASAN RUTE', margin, currentY);
      currentY += 8;
      
      // Tabel ringkasan rute
      const routeHeaders = ['#', 'Dari', 'Ke', 'Jarak', 'Durasi'];
      const routeData = currentRouteData.legs.map((leg, index) => [
        index + 1,
        leg.start_address.length > 50 ? leg.start_address.substring(0, 47) + '...' : leg.start_address,
        leg.end_address.length > 50 ? leg.end_address.substring(0, 47) + '...' : leg.end_address,
        leg.distance?.text || '-',
        leg.duration?.text || '-'
      ]);
      
      // Tambahkan total
      routeData.push(['', '', 'TOTAL', currentRouteData.totalDistance, currentRouteData.totalDuration]);
      
      doc.autoTable({
        head: [routeHeaders],
        body: routeData,
        startY: currentY,
        margin: { left: margin, right: margin },
        styles: { 
          fontSize: 9,
          cellPadding: 3,
          lineColor: [200, 200, 200],
          lineWidth: 0.5
        },
        headStyles: { 
          fillColor: [102, 126, 234],
          textColor: [255, 255, 255],
          fontStyle: 'bold',
          fontSize: 10
        },
        alternateRowStyles: { fillColor: [248, 250, 252] },
        columnStyles: {
          0: { cellWidth: 12, halign: 'center' }, // Nomor
          1: { cellWidth: 65, halign: 'left' },  // Dari
          2: { cellWidth: 65, halign: 'left' },  // Ke
          3: { cellWidth: 25, halign: 'center' }, // Jarak
          4: { cellWidth: 25, halign: 'center' }  // Durasi
        },
        didDrawPage: function(data) {
          // Footer untuk setiap halaman
          const pageNumber = doc.internal.getCurrentPageInfo().pageNumber;
          const totalPages = doc.internal.getNumberOfPages();
          
          doc.setFontSize(8);
          doc.setTextColor(100, 100, 100);
          doc.text(`Halaman ${pageNumber} dari ${totalPages}`, margin, pageHeight - 10);
          doc.text(`Mapping Rute Pengiriman`, pageWidth - margin - 50, pageHeight - 10);
        }
      });
      
      // Daftar drop points
      currentY = doc.lastAutoTable.finalY + 15;
      
      // Cek apakah perlu halaman baru
      if (currentY > pageHeight - 80) {
        doc.addPage();
        currentY = 20;
      }
      
      doc.setFontSize(14);
      doc.setFont(undefined, 'bold');
      doc.setTextColor(102, 126, 234);
      doc.text('DAFTAR DROP POINTS', margin, currentY);
      currentY += 8;
      
      const dropHeaders = ['#', 'Nama Customer', 'No. Dokumen', 'Alamat', 'Notes', 'Urutan'];
      const dropData = currentRouteData.dropPoints.map((drop, index) => [
        index + 1,
        drop.name.length > 25 ? drop.name.substring(0, 22) + '...' : drop.name,
        drop.docNo.length > 15 ? drop.docNo.substring(0, 12) + '...' : drop.docNo,
        drop.address || '-', // Alamat lengkap tanpa dipotong
        (drop.notes || '').length > 30 ? (drop.notes || '').substring(0, 27) + '...' : (drop.notes || '-'),
        `Drop ${index + 1}`
      ]);
      
      doc.autoTable({
        head: [dropHeaders],
        body: dropData,
        startY: currentY,
        margin: { left: margin, right: margin },
        styles: { 
          fontSize: 8,
          cellPadding: 2.5,
          lineColor: [200, 200, 200],
          lineWidth: 0.5,
          overflow: 'linebreak'
        },
        headStyles: { 
          fillColor: [102, 126, 234],
          textColor: [255, 255, 255],
          fontStyle: 'bold',
          fontSize: 9
        },
        alternateRowStyles: { fillColor: [248, 250, 252] },
        columnStyles: {
          0: { cellWidth: 10, halign: 'center' }, // Nomor
          1: { cellWidth: 30, halign: 'left' },   // Nama
          2: { cellWidth: 22, halign: 'center' }, // No. Dokumen
          3: { cellWidth: 80, halign: 'left', overflow: 'linebreak' },   // Alamat - lengkap dengan wrapping
          4: { cellWidth: 35, halign: 'left' },   // Notes
          5: { cellWidth: 18, halign: 'center' }  // Urutan
        },
        didDrawPage: function(data) {
          // Footer untuk setiap halaman
          const pageNumber = doc.internal.getCurrentPageInfo().pageNumber;
          const totalPages = doc.internal.getNumberOfPages();
          
          doc.setFontSize(8);
          doc.setTextColor(100, 100, 100);
          doc.text(`Halaman ${pageNumber} dari ${totalPages}`, margin, pageHeight - 10);
          doc.text(`Mapping Rute Pengiriman`, pageWidth - margin - 50, pageHeight - 10);
        }
      });
      
      // Download
      doc.save(`ringkasan-rute-${new Date().toISOString().split('T')[0]}.pdf`);
    }

    // Fungsi untuk download Excel
    function downloadExcel() {
      if (!currentRouteData) {
        showError('Tidak ada data rute untuk didownload. Silakan proses rute terlebih dahulu.');
        return;
      }

      // Buat workbook baru
      const wb = XLSX.utils.book_new();
      
      // Sheet 1: Ringkasan Rute
      const routeData = [
        ['RINGKASAN RUTE PENGIRIMAN'],
        [''],
        ['Alamat Toko:', currentRouteData.storeAddress],
        ['Tanggal Dibuat:', new Date().toLocaleString('id-ID')],
        [''],
        ['RINGKASAN RUTE'],
        ['#', 'Dari', 'Ke', 'Jarak', 'Durasi']
      ];

      // Tambahkan data rute
      currentRouteData.legs.forEach((leg, index) => {
        routeData.push([
          index + 1,
          leg.start_address,
          leg.end_address,
          leg.distance?.text || '-',
          leg.duration?.text || '-'
        ]);
      });

      // Tambahkan total
      routeData.push(['', '', 'TOTAL', currentRouteData.totalDistance, currentRouteData.totalDuration]);

      // Buat worksheet untuk ringkasan rute
      const ws1 = XLSX.utils.aoa_to_sheet(routeData);
      
      // Styling untuk header
      ws1['!cols'] = [
        { wch: 5 },   // #
        { wch: 50 },  // Dari
        { wch: 50 },  // Ke
        { wch: 15 },  // Jarak
        { wch: 15 }   // Durasi
      ];

      // Merge cells untuk header
      ws1['!merges'] = [
        { s: { r: 0, c: 0 }, e: { r: 0, c: 4 } }, // Judul utama
        { s: { r: 2, c: 0 }, e: { r: 2, c: 1 } }, // Alamat Toko
        { s: { r: 3, c: 0 }, e: { r: 3, c: 1 } }, // Tanggal
        { s: { r: 5, c: 0 }, e: { r: 5, c: 4 } }  // Ringkasan Rute
      ];

      XLSX.utils.book_append_sheet(wb, ws1, 'Ringkasan Rute');

      // Sheet 2: Daftar Drop Points
      const dropData = [
        ['DAFTAR DROP POINTS'],
        [''],
        ['Alamat Toko:', currentRouteData.storeAddress],
        ['Tanggal Dibuat:', new Date().toLocaleString('id-ID')],
        [''],
        ['DETAIL DROP POINTS'],
        ['#', 'Nama Customer', 'No. Dokumen', 'Alamat', 'Notes', 'Urutan']
      ];

      // Tambahkan data drop points
      currentRouteData.dropPoints.forEach((drop, index) => {
        dropData.push([
          index + 1,
          drop.name,
          drop.docNo,
          drop.address,
          drop.notes || '',
          `Drop ${index + 1}`
        ]);
      });

      // Buat worksheet untuk drop points
      const ws2 = XLSX.utils.aoa_to_sheet(dropData);
      
      // Styling untuk header
      ws2['!cols'] = [
        { wch: 5 },   // #
        { wch: 25 },  // Nama Customer
        { wch: 20 },  // No. Dokumen
        { wch: 50 },  // Alamat
        { wch: 30 },  // Notes
        { wch: 15 }   // Urutan
      ];

      // Merge cells untuk header
      ws2['!merges'] = [
        { s: { r: 0, c: 0 }, e: { r: 0, c: 5 } }, // Judul utama
        { s: { r: 2, c: 0 }, e: { r: 2, c: 1 } }, // Alamat Toko
        { s: { r: 3, c: 0 }, e: { r: 3, c: 1 } }, // Tanggal
        { s: { r: 5, c: 0 }, e: { r: 5, c: 5 } }  // Detail Drop Points
      ];

      XLSX.utils.book_append_sheet(wb, ws2, 'Drop Points');

      // Sheet 3: Statistik Rute
      const statsData = [
        ['STATISTIK RUTE PENGIRIMAN'],
        [''],
        ['Alamat Toko:', currentRouteData.storeAddress],
        ['Tanggal Dibuat:', new Date().toLocaleString('id-ID')],
        [''],
        ['STATISTIK'],
        ['Total Jarak:', currentRouteData.totalDistance],
        ['Total Durasi:', currentRouteData.totalDuration],
        ['Jumlah Drop Points:', currentRouteData.dropPoints.length],
        [''],
        ['RINCIAN PER SEGMENT'],
        ['Segment', 'Dari', 'Ke', 'Jarak', 'Durasi', 'Persentase Jarak']
      ];

      // Hitung total jarak dalam meter untuk persentase
      let totalMeters = 0;
      currentRouteData.legs.forEach(leg => {
        totalMeters += leg.distance?.value || 0;
      });

      // Tambahkan rincian per segment
      currentRouteData.legs.forEach((leg, index) => {
        const segmentMeters = leg.distance?.value || 0;
        const percentage = totalMeters > 0 ? ((segmentMeters / totalMeters) * 100).toFixed(1) + '%' : '0%';
        
        statsData.push([
          `Segment ${index + 1}`,
          leg.start_address,
          leg.end_address,
          leg.distance?.text || '-',
          leg.duration?.text || '-',
          percentage
        ]);
      });

      // Buat worksheet untuk statistik
      const ws3 = XLSX.utils.aoa_to_sheet(statsData);
      
      // Styling untuk header
      ws3['!cols'] = [
        { wch: 15 },  // Segment
        { wch: 40 },  // Dari
        { wch: 40 },  // Ke
        { wch: 15 },  // Jarak
        { wch: 15 },  // Durasi
        { wch: 15 }   // Persentase
      ];

      // Merge cells untuk header
      ws3['!merges'] = [
        { s: { r: 0, c: 0 }, e: { r: 0, c: 5 } }, // Judul utama
        { s: { r: 2, c: 0 }, e: { r: 2, c: 1 } }, // Alamat Toko
        { s: { r: 3, c: 0 }, e: { r: 3, c: 1 } }, // Tanggal
        { s: { r: 5, c: 0 }, e: { r: 5, c: 5 } }  // Statistik
      ];

      XLSX.utils.book_append_sheet(wb, ws3, 'Statistik');

      // Download file
      const fileName = `ringkasan-rute-${new Date().toISOString().split('T')[0]}.xlsx`;
      XLSX.writeFile(wb, fileName);
    }

    // Fungsi untuk download gambar
    function downloadImage() {
      if (!currentRouteData) {
        showError('Tidak ada data rute untuk didownload. Silakan proses rute terlebih dahulu.');
        return;
      }

      // Tunggu sebentar agar elemen ter-render
      setTimeout(() => {
        const element = document.getElementById('printArea');
        
        html2canvas(element, {
          scale: 2,
          useCORS: true,
          allowTaint: true,
          backgroundColor: '#ffffff',
          width: element.offsetWidth,
          height: element.offsetHeight
        }).then(canvas => {
          // Buat link download
          const link = document.createElement('a');
          link.download = `ringkasan-rute-${new Date().toISOString().split('T')[0]}.png`;
          link.href = canvas.toDataURL('image/png');
          
          // Trigger download
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          
        }).catch(error => {
          console.error('Error generating image:', error);
          showError('Gagal membuat gambar. Silakan coba lagi.');
        });
      }, 100);
    }

    function applyCityBiasToAutocompletes() {
      if (cityPlace && cityPlace.geometry && cityPlace.geometry.viewport) {
        const viewport = cityPlace.geometry.viewport;
        if (storeAutocomplete) {
          storeAutocomplete.setBounds(viewport);
          storeAutocomplete.setOptions({ strictBounds: false });
        }
        customerAutocompletes.forEach(ac => {
          ac.setBounds(viewport);
          ac.setOptions({ strictBounds: false });
        });
      }
    }

    function initMap() {
      map = new google.maps.Map(document.getElementById('map'), {
        center: { lat: -6.200000, lng: 106.816666 },
        zoom: 10,
        mapTypeControl: false,
        streetViewControl: false,
        gestureHandling: 'greedy',
        zoomControl: true,
        zoomControlOptions: {
          position: google.maps.ControlPosition.RIGHT_BOTTOM
        },
        fullscreenControl: true,
        fullscreenControlOptions: {
          position: google.maps.ControlPosition.RIGHT_BOTTOM
        }
      });
      infoWindow = new google.maps.InfoWindow();
      geocoder = new google.maps.Geocoder();

      directionsService = new google.maps.DirectionsService();
      directionsRenderer = new google.maps.DirectionsRenderer({ suppressMarkers: true, suppressPolylines: true });
      directionsRenderer.setMap(map);
      distanceMatrixService = new google.maps.DistanceMatrixService();

      cityAutocomplete = new google.maps.places.Autocomplete(dom.cityInput(), {
        fields: ['geometry', 'formatted_address', 'name', 'address_components'],
        types: ['(cities)'],
        componentRestrictions: { country: ['id'] },
      });
      cityAutocomplete.addListener('place_changed', () => {
        cityPlace = cityAutocomplete.getPlace();
        if (cityPlace && cityPlace.geometry) {
          // Update input dengan alamat lengkap
          if (cityPlace.formatted_address) {
            dom.cityInput().value = cityPlace.formatted_address;
          }
          map.fitBounds(cityPlace.geometry.viewport || new google.maps.LatLngBounds(cityPlace.geometry.location));
          applyCityBiasToAutocompletes();
        }
      });

      storeAutocomplete = new google.maps.places.Autocomplete(dom.storeAddress(), {
        fields: ['geometry', 'formatted_address', 'name', 'address_components'],
        types: ['geocode'],
        componentRestrictions: { country: ['id'] },
      });

      // Render list customer kosong
      renderCustomerList('address');
      renderCustomerList('coordinates');
      renderCustomerList('hybrid');

      // Load store database
      loadStoreDatabase();

      dom.lockStoreBtn().addEventListener('click', toggleStoreLock);
      dom.storeSelect().addEventListener('change', handleStoreSelection);
      dom.addCustomerBtn().addEventListener('click', () => openCustomerModal('address'));
      document.getElementById('addCustomerCoordBtn').addEventListener('click', () => openCustomerModal('coordinates'));
      document.getElementById('addCustomerHybridBtn').addEventListener('click', () => openCustomerModal('hybrid'));
      dom.processBtn().addEventListener('click', processRoute);
      dom.resetBtn().addEventListener('click', resetAll);
      
      // Customer modal event listeners
      dom.customerForm().addEventListener('submit', (e) => {
        e.preventDefault();
        saveCustomerFromModal();
      });
      dom.closeCustomerModal().addEventListener('click', closeCustomerModal);
      dom.cancelCustomerBtn().addEventListener('click', closeCustomerModal);
      // Close modal saat klik di luar modal
      dom.customerModal().addEventListener('click', (e) => {
        if (e.target === dom.customerModal()) {
          closeCustomerModal();
        }
      });
      
      // Upload dan Download Template event listeners
      document.getElementById('downloadTemplateAddressBtn').addEventListener('click', downloadTemplateAddress);
      document.getElementById('downloadTemplateCoordBtn').addEventListener('click', downloadTemplateCoord);
      document.getElementById('downloadTemplateHybridBtn').addEventListener('click', downloadTemplateHybrid);
      
      // Button upload untuk trigger file input
      document.getElementById('uploadAddressBtn').addEventListener('click', () => {
        document.getElementById('uploadAddressFile').click();
      });
      
      document.getElementById('uploadCoordBtn').addEventListener('click', () => {
        document.getElementById('uploadCoordFile').click();
      });
      
      document.getElementById('uploadHybridBtn').addEventListener('click', () => {
        document.getElementById('uploadHybridFile').click();
      });
      
      document.getElementById('uploadAddressFile').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
          processUploadedAddressFile(file);
          // Reset input untuk memungkinkan upload file yang sama lagi
          e.target.value = '';
        }
      });
      
      document.getElementById('uploadCoordFile').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
          processUploadedCoordFile(file);
          // Reset input untuk memungkinkan upload file yang sama lagi
          e.target.value = '';
        }
      });
      
      document.getElementById('uploadHybridFile').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
          processUploadedHybridFile(file);
          // Reset input untuk memungkinkan upload file yang sama lagi
          e.target.value = '';
        }
      });
      
      // Form tab switcher event listeners
      document.querySelectorAll('.form-tab-btn').forEach(btn => {
        btn.addEventListener('click', () => switchFormTab(btn.dataset.formTab));
      });
      
      // Modal event listeners
      dom.viewSummaryBtn().addEventListener('click', () => {
        populateModal();
        openModal();
      });
      dom.closeModal().addEventListener('click', closeModal);
      dom.routeModal().addEventListener('click', (e) => {
        if (e.target === dom.routeModal()) closeModal();
      });
      
      // Tab event listeners
      document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.addEventListener('click', () => switchTab(btn.dataset.tab));
      });
      
      // Download buttons in modal
      dom.modalDownloadPdf().addEventListener('click', downloadPDF);
      dom.modalDownloadExcel().addEventListener('click', downloadExcel);
      dom.modalDownloadImg().addEventListener('click', downloadImage);
    }

    window.initMap = initMap;

    // PRINT FEATURE
    document.addEventListener('DOMContentLoaded', function() {
      const printBtn = document.getElementById('printBtn');
      if (printBtn) {
        printBtn.addEventListener('click', function() {
          // Sembunyikan elemen yang tidak perlu saat print
          document.body.classList.add('printing');
          window.print();
          setTimeout(() => document.body.classList.remove('printing'), 1000);
        });
      }
    });
  </script>
  <!-- Pastikan API key memiliki akses Maps JavaScript API, Places API, dan Distance Matrix API -->
  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAxWsTliFhn3XDDCyjOuB4N2DYAwgksfBw&libraries=places,geometry&callback=initMap" async defer></script>
</body>
</html>
